[{"path":"https://optad.github.io/adoptr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 adoptr authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr.html","id":"two-stage-designs-for-clinical-trials","dir":"Articles","previous_headings":"","what":"Two-stage designs for clinical trials","title":"Get started with adoptr","text":"prospectively planned confirmatory clinical trials long-standing debate merits allowing pre-planned interim analyses stop modify ongoing trial, cf.  Bauer et al., 2016. common consensus two-stage designs still maintain strict control maximal type one error rate despite data dependent decision interim analysis. authors use combination function approaches combine either independent p values test statistics respective stages. pre-specified weights maintains type one error rate control. adoptr provide tools explore optimal two-stage designs one two-arm clinical trials (asymptotically) normally distributed stage-wise independent test statistics. Pilz et al., 2019, argued techniques necessary, fact, counter-productive, since pre-specified weights might sub-optimal. Instead, one may see problem defining optimal two-stage designs variational problem find optimal configuration \\[ \\mathcal{D}:=\\big(n_1, c_1^e, c_1^f, n_2(\\cdot), c_2(\\cdot)\\big) \\] directly given objective function potentially set constraints. relaxation mixed-integer problem real numbers can solved standard methods analysis. E.g., one construct implicit solution solving corresponding Euler-Lagrange equation given first-stage find optimal first-stage configuration, cf. Pilz et al., 2019. Instead, adoptr package implements direct numerical solution algorithm embedding variation problem via set pivot points \\(\\mathbb{R}^k\\) solving corresponding finite-dimensional problem using gradient-free numerical optimization procedures (COBYLA / nloptr).","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Get started with adoptr","text":"Consider two-arm case comparing two group means mean. Let \\(\\delta\\) difference means assume aim reject null hypothesis \\(\\mathcal{H}_0: \\delta \\leq 0\\). assume power 80% \\(\\delta=0.4\\) type-one-error rate 2.5% boundary null hypothesis \\(\\delta\\leq0.0\\) required. situation, one-sided t-test require sample size \\(51\\) individuals per-group. willing accept fact sample size two-stage design inherently unknown planning stage, reduce expected sample size alternative optimizing two-stage design respect quantity. Since two-stage design, definition, degrees freedom single-stage design, must least good terms expected sample size single-stage design - expected sample size always 51.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr.html","id":"define-hypotheses-and-data-generating-mechanism","dir":"Articles","previous_headings":"Example","what":"Define hypotheses and data-generating mechanism","title":"Get started with adoptr","text":"First, define null alternative hypotheses prior distributions unknown parameter \\(\\delta\\). Next, define data-generating mechanism (data distribution). Currently, normally distributed test statistics known variance, normal approximation binary endpoints supported. example, choose normal distribution, .e., assume continuous outcome. example binomial data distribution, cf. vignette composite scores.","code":"library(adoptr) H_0 <- PointMassPrior(.0, 1) H_1 <- PointMassPrior(.4, 1) datadist <- Normal(two_armed = FALSE)"},{"path":"https://optad.github.io/adoptr/articles/adoptr.html","id":"specify-optimization-problem","dir":"Articles","previous_headings":"Example","what":"Specify optimization problem","title":"Get started with adoptr","text":"begin defining expected sample size alternative hypothesis: Similarly, can define power type-one-error rate integrating conditional power respect alternative null hypothesis respectively: complete problem specification, need provide initial design integration order Gaussian quadrature rule used numerical integration variational objective \\(c_1^f\\) \\(c_1^e\\). adoptr provides heuristic method obtain initial design. based one-stage design specific constraints type one error rate power. However, may efficient use situation-specific initial design. decision boundaries heuristically picked concordance single-stage design. can check whether initial design fulfills constraints operating characteristics: can now proceed defining solving optimization problem: , default setting optimizer box constraints seem worked . numerical procedure converged iterations. can plot resulting optimized design may plotted together conditional power.  Numerical integration yields expected sample size way single-stage 51. can check results simulated values values simulation numerical integration almost identical constraints also met almost perfectly:","code":"ess <- ExpectedSampleSize(datadist, H_1) power <- Power(datadist, H_1) toer  <- Power(datadist, H_0) initial_design <- get_initial_design(   theta = .4,   alpha = .025,   beta  = .2,   type  = \"two-stage\",   dist  = datadist,   order = 7L ) evaluate(power, initial_design) #> [1] 0.9401854 evaluate(toer, initial_design) #> [1] 0.0246875 opt_res <- minimize(      ess,      subject_to(     power >= 0.8,     toer  <= .025   ),      initial_design ) opt_res$nloptr_return$iterations plot(   opt_res$design,    \"Conditional power\" = ConditionalPower(datadist, H_1) ) evaluate(ess, opt_res$design) #> [1] 39.85638 df_sim <- simulate(   opt_res$design,    nsim = 10^6,    dist = datadist,    theta = .4,    seed = 42 )  n <- df_sim$n1 + df_sim$n2 mean(n) #> [1] 39.83997 sd(n) / sqrt(length(n)) #> [1] 0.01372661 evaluate(toer, opt_res$design) #> [1] 0.02500571 evaluate(power, opt_res$design) #> [1] 0.7985309"},{"path":"https://optad.github.io/adoptr/articles/adoptr.html","id":"variations","dir":"Articles","previous_headings":"Example","what":"Variations","title":"Get started with adoptr","text":"purpose adoptr provide high-level interface exploring comparing different designs experiment different combinations objective functions constraints. particular, adoptr supports: Important predefined scores (conditional) power sample size functions well framework constraints scores (cf. conditional scores). Arbitrary continuous discrete prior distributions single location parameter \\(\\theta\\) test statistic. Support simple arithmetic operations scores quickly define weighted sums etc. (cf. composite scores). Relatively flexible framework defining new scores.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"Confirmatory clinical trials conducted strictly regulated environment. key quality criterion put forward relevant agencies (US Food Drug Administration et al. (2019), Committee Medicinal Products Human Use others (2007)) study supposed provide evidence regulatory acceptance new drug treatment strict type one error rate control. requirement often seen conflicting perceived need make trials flexible , e.g., early stopping futility, group-sequential enrollment, even adaptive sample size recalculation. excellent historical review development field adaptive clinical trial designs struggles along way given Bauer et al. (2015). manuscript, focus lies exclusively adaptive two-stage designs one unblinded interim analysis. early stopping futility efficacy allowed final sample size well critical value reject null hypothesis chosen data-driven way. plethora methods modifying design ongoing trial based interim results without compromising type one error rate control (Bauer et al. 2015) criteria deciding adaptation performed interim analysis perform interim analysis still widely based heuristics. Bauer et al. mention issue guiding adaptive decisions interim principled (.e., ‘optimal’) way stating ‘[t]question might arise potential decisions made interim stages might better placed upfront planning stage.’ Following Mehta Pocock (2011), Jennison Turnbull (2015) developed principle approach optimal interim sample size modifications, .e., conduct interim decision (conditional interim results) optimizes unconditional performance score. approach, however, still restricted unnecessarily. Recently, Pilz et al. (2019) extended work fully general variational problem optimization problem given performance score (optionally constraints) solved sample size adaptation function critical value function time point interim decision simultaneously. approach application ideas put forward single-arm trials binary endpoint several years (Englert Kieser (2013), Kunzmann Kieser (2016), Kunzmann Kieser (2020)) setting continuous test statistics. Clearly, relaxing problem continuous sample sizes test statistics, theory becomes much tractable, important connections conditional unconditional optimality can discussed much easier (Pilz et al. 2019). key insight recent development fact true challenge designing adaptive trial less technical methodology controlling type one error rate rather choice optimality criterion. issue much less pressing single-stage designs since sensible criteria equivalent minimizing overall sample size. Thus, case, ‘design’ often completely specified given power type one error rate constraints. complex adaptive designs, however, much sensible criteria (minimize maximal sample size, expected sample size, expected costs, etc.) balance conditional unconditional properties must explicitly specified (cf. Section 6). added complexity might seen daunting practitioners, also chance tailoring adaptive designs specifically particular situation. R-package (R Core Team 2019) adoptr aims providing simple yet customizable interface specifying broad class objective functions constraints single- two-arm, one- two-stage designs approximately normally distributed endpoints. goal adoptr enable relatively easy experimentation different notions optimality shift focus optimize optimize. following, first give definition problem setting addressed adoptr technicalities translating underlying variational problem simple multivariate optimization problem motivating need R-package. present core functionality adoptr addressing issue facilitating validation open-source software regulated environment discussing potential future work adoptr.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:setting","dir":"Articles","previous_headings":"","what":"Setting","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"consider problem two-stage, two-arm design establish superiority treatment placebo respect mean difference. Assume end data \\(Y_j^{g, }\\) observed \\(j\\)-th individual trial stage \\(\\\\{1,2\\}\\) treatment (\\(g=T\\)) placebo (\\(g=C\\)). Let \\(n_i\\) per-group sample size stage \\(\\) consider stage-wise test statistics \\[   X_i := \\frac{\\sum_{j=1}^{n_i}Y_j^{T,} - \\sum_{j=1}^{n_i}Y_j^{C,}}{\\sigma\\,\\sqrt{2\\,n_i}} \\] \\(=1,2\\). assumption \\(Y_j^{g, }\\stackrel{iid}{\\sim} F_g\\) \\(\\boldsymbol{E}[F_T] - \\boldsymbol{E}[F_C] = \\theta\\) common variance \\(\\sigma^2\\), central limit theorem, asymptotic distribution \\(X_1\\) \\(\\mathcal{N}(\\sqrt{n_1/2}\\, \\theta, 1)\\). Formally, null hypothesis superiority test thus \\(\\mathcal{H}_0:\\theta\\leq 0\\). Based interim outcome \\(X_1\\), decision can made whether either stop trial early futility \\(X_1<c_1^f\\), stop trial early efficacy (early rejection null hypothesis) \\(X_1>c_1^e\\), enter stage two \\(X_1\\[c_1^f, c_1^e]\\). Conditional proceeding second stage, holds \\(X_2\\,|\\,X_1\\[c_1^f, c_1^e]\\sim\\mathcal{N}(\\sqrt{n_2/2}\\, \\theta, 1)\\). second stage, null hypothesis rejected \\(X_2 > c_2(X_1)\\) stage-two critical value \\(c_2:x_1\\mapsto c_2(x_1)\\). test \\(\\mathcal{H}_0\\) significance level \\(\\alpha\\), stage-one critical values \\(c_1^f\\) \\(c_1^e\\) well \\(c_2(\\cdot)\\) must chosen way protects overall maximal type one error rate \\(\\alpha\\). Note convenient define \\(c_2(x_1) = \\infty\\) \\(x_1<c_1^f\\) \\(c_2(x_1) = -\\infty\\) \\(x_1>c_1^e\\) since power curve design given \\(\\theta\\mapsto\\boldsymbol{Pr}_\\theta\\big[X_2>c_2(X_1)\\big]\\). results classical group-sequential design several methods proposed literature choosing early-stopping boundaries \\(c_1^f\\) \\(c_1^e\\) (O’Brien Fleming (1979), Pocock (1977)) defining stage-two rejection boundary function \\(c_2(\\cdot)\\) (Bauer Köhne (1994), Hedges Olkin (1985)). Often, inverse-normal combination test (Lehmacher Wassmer 1999) applied \\(c_2(\\cdot)\\) defined linear function stage-one test-statistic \\[   c_2(x_1) = \\frac{c - w_1 x_1}{w_2}‚ \\] critical value \\(c\\) predefined weights \\(w_1\\) \\(w_2\\). commonly, stage-wise test statistics weighted terms respective sample sizes, .e., \\(w_1 = \\sqrt{n_1 / (n_1+n_2)}\\) \\(w_2 = \\sqrt{n_2 / (n_1+n_2)}\\). choice weights optimal sense minimizes variance final test statistic assumed sample sizes indeed realized (Zaykin 2011). Note, however, prespecified weights become inefficient sample size deviates strongly anticipated value (cf. Wassmer Brannath (2016), chapter 6.2.5). natural extension group-sequential framework allow second stage sample size also depend observed interim outcome, .e., consider function \\(n_2:x_1\\mapsto n_2(x_1)\\) instead fixed value \\(n_2\\). ‘adaptive’ two-stage designs thus completely characterized five-tuple \\(\\mathcal{D}:=\\big(n_1, c_1^f, c_1^e, n_2(\\cdot), c_2(\\cdot)\\big)\\). required sample size critical value single-stage design uniquely defined given type one error rate power constraints, much less clear design parameters two-stage design selected. especially true since \\(n_2\\) \\(c_2\\) functions thus parameter space fact infinite-dimensional. order compare different choices design parameters, appropriate scoring criteria essential. widely applied criterion expected sample size alternative hypothesis (see, e.g., Jennison Turnbull (2015)). However, variety scoring criteria incorporated even combined order rate two-stage design. instance, conditional power defined probability reject null hypothesis alternative given interim result \\(X_1=x_1\\): \\[ \\operatorname{CP}_\\theta(x_1) := \\boldsymbol{Pr}_\\theta \\big[X_2 > c_2(X_1) \\, \\big| \\, X_1=x_1\\big]. \\] Hence, conditional power conditional score given power conditioned first-stage outcome \\(X_1=x_1\\). Vice versa, power can seen unconditional score obtained integrating conditional power possible stage-one outcomes, .e., \\[ \\operatorname{Power_\\theta} = \\boldsymbol{E}_\\theta\\big[\\operatorname{CP}(X_1)\\big]. \\] Intuitively, makes sense require minimal conditional power upon continuation second stage since one might otherwise continue trial little prospect still rejecting null hypothesis. demonstrate consequences heuristic Section 6.4. scoring criterion selected, design parameters may chosen order optimize objective. first ones address problem Jennison Turnbull (2015) minimized expected sample size \\[ \\text{ESS}_{\\theta}(\\mathcal{D}) := \\boldsymbol{E}_{\\theta} \\big[n(X_1) \\big] := \\boldsymbol{E}_{\\theta} \\big[n_1 + n_2(X_1) \\big] \\] two-stage design given \\(n_1,c_1^f, c_1^e\\) respect \\(n_2(\\cdot)\\) given power type one error rate constraints. function \\(c_2(\\cdot)\\), however, optimized. Instead, Jennison Turnbull (2015) used inverse-normal combination test approach derive \\(c_2\\) given \\(n_2(\\cdot)\\) \\(n_1\\). Pilz et al. (2019), authors demonstrated restriction necessary variational problem deriving functions \\(n_2(\\cdot)\\) \\(c_2(\\cdot)\\) given \\(n_1,c_1^f, c_1^e\\) minimize expected sample size can solved analyzing corresponding Euler-Lagrange equation. Nesting step standard optimization stage-one parameters allows identifying optimal set design parameters without imposing parametric assumptions \\(c_2(\\cdot)\\). result, fully optimal design \\(\\mathcal{D}^*:=\\big(n_1^*, c_1^{f,*}, c_1^{e, *}, n_2^*(\\cdot), c_2^*(\\cdot)\\big)\\) following general optimization problem derived \\[\\begin{align} & \\text{minimize} && \\operatorname{ESS}_{\\theta_1}(\\mathcal{D}) &&&& \\\\ & \\text{subject :} && \\boldsymbol{Pr}_{\\theta_0}\\big[X_2>c_2(X_1)\\big] &&\\leq \\alpha, &&&& \\\\ &&& \\boldsymbol{Pr}_{\\theta_1}\\big[X_2>c_2(X_1)\\big] &&\\geq 1-\\beta &&&& \\end{align}\\] \\(\\theta_0=0\\).","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"direct-variational-perspective","dir":"Articles","previous_headings":"","what":"Direct variational perspective","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"adoptr, simpler solution strategy solving Euler-Lagrange equation locally applied problem class. propose embed entire problem finite-dimensional parameter space solve corresponding problem stage-one stage-two design parameters simultaneously using standard numerical libraries. .e., adopt direct approach solving variational problem. done defining discrete set pivot points \\(\\widetilde{x}_1^{()}\\(c_1^f, c_1^e), =1,\\ldots,k\\), interpolating \\(c_2\\) \\(n_2\\) pivots. use cubic Hermite splines (Fritsch Carlson 1980) sufficiently flexible, even moderate number pivots, approximate realistic stage-two sample size critical value functions. Since optimal functions generally smooth (Pilz et al. 2019) well suited spline interpolation. Within adoptr validation report (cf. Section 7) investigate empirically shape approximated functions increasing number pivots value 5 7 improve optimization results. latter implies relatively small number pivot points appears sufficient obtain valid spline approximations optimal functions. Note pivots needed continuation region since functions (piecewise) constant within early stopping regions. adoptr, pivots defined nodes Gaussian quadrature rule degree \\(k\\). choice allows fast precise numerical integration conditional score continuation region, e.g., \\[\\begin{align} \\text{ESS}_{\\theta}(\\mathcal{D})  = \\int n(x_1) f_{\\theta} (x_1) \\operatorname{d} x_1 \\approx n_1 + \\sum_{=1}^{k} \\omega_i\\, n_2\\big(\\widetilde{x}_1^{()}\\big) f_{\\theta} \\big(\\widetilde{x}_1^{()}\\big), \\end{align}\\] \\(f_\\theta\\) probability density function \\(X_1\\,|\\,\\theta\\) \\(\\omega_i\\) corresponding weights integration rule. weights depend \\(k\\) nodes just need scaled integration interval. Consequentially, objective function smooth optimization parameters resulting optimization problem dimension \\(2k+3\\), tuning parameters \\(\\big(n_1, c_1^f, c_1^e, n_2\\big(\\widetilde{x}_1^{(1)}\\big), \\dots, n_2\\big(\\widetilde{x}_1^{(k)}\\big), c_2\\big(\\widetilde{x}_1^{(1)}\\big), \\dots, c_2\\big(\\widetilde{x}_1^{(k)}\\big)\\big)\\). Standard numerical solvers may employed minimize . Since adoptr enables generic objectives (cf. Section 6.3), uses gradient-free optimizer COBYLA (Powell 1994) internally via R-package nloptr (Johnson (2018), Ypma, Borchers, Eddelbuettel (2018)). commonly used unconditional performance scores \\(S(\\mathcal{D})\\) can seen expected values conditional scores \\(S(\\mathcal{D}|X_1)\\) \\(S(\\mathcal{D}) = \\boldsymbol{E}\\big[S(\\mathcal{D}|X_1)\\big]\\) similar way power expected sample size. ‘integral score’ can computed quickly reliably adoptr via choice pivots outlined . correctness numerically integrated scores checked adoptr validation report comparing numerical integrals simulated results. Note tacitly relaxed sample sizes real numbers argument fact restricted positive integers. Integer-valued \\(n_1\\) \\(n_2\\) , however, lead NP-hard mixed-integer problem. experiments, found merely rounding \\(n_1\\) \\(n_2\\) optimization works fine. extensive validation suite (cf. Section 7) evaluates numerical integration simulation whether included constraints fulfilled optimal designs rounded sample sizes. now, neither constraints violated efficiency loss respect underlying objective function observed. theory, one re-adjust decision boundaries rounded sample sizes, failed see practical benefit , even small trials rounding error largest (data shown).","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"the-need-for-an-r-package","dir":"Articles","previous_headings":"","what":"The need for an R package","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"Bauer et al. (2015) state adequate statistical software adaptive designs ‘increasingly needed evaluate adaptations find reasonable strategies’. Commercial software JMP (SAS Institute Inc., n.d.) Minitab (Minitab, Inc. 2020) allow planning analyzing wide range experimental setups. Amongst others, provide tools randomization, stratification, block-building, D-optimal designs. general purpose statistical software packages , however, allow planning specialized multi-stage designs encountered clinical trials. group-sequential designs, planning capabilities available SAS procedure seqdesign (SAS Institute Inc., n.d.b), PASS (NCSS 2019), ADDPLAN (ICON plc 2020). East (Cytel 2020) also supports design, simulation analysis experiments interim analyses. East ADAPT East SURVADAPT modules support sample size recalculation. Furthermore, various open-source R-packages analysis multi-stage designs. package adaptTest (Vandemeulebroecke 2009) implements combination tests adaptive two-stage designs. AGSDest (Hack, Brannath, Brueckner 2019) allows estimation computation confidence intervals adaptive group-sequential designs. detailed overviews software adaptive clinical trial designs can found Bauer et al. (2015), chapter 6, Tymofyeyev (2014). choice software optimally designing two- multi-stage designs, however, much limited. Current R-packages concerned optimal clinical trial designs OptGS (Wason Burkardt (2015), Wason (2015)) rpact (Wassmer Pahlke 2019). , however, exclusively focused group-sequential designs lack ability specify custom objective functions constraints. lack flexibility formulating objective function constraints might lead --shelf solutions entirely reflecting needs particular trial consequentially resulting inefficient designs. R-package adoptr aims providing simple interactive yet flexible interface addressing range optimization problems encountered two-stage one- two-arm clinical trials. particular, adoptr allows model priori uncertainty \\(\\theta\\) via prior distributions thus supports optimization uncertainty (cf. Section 6.2). adoptr also supports combination conditional (\\(X_1\\)) unconditional scores constraints address concerns type-one-error-rate control (unconditional score) , e.g., minimal conditional power (conditional score) simultaneously (cf. Section 6.3). facilitate adoption advanced trial designs clinical trials community, adoptr also features extensive test validation suite (cf. Section 7). following, outline key design principles adoptr. Interactivity: major advantage R-programming language powerful metaprogramming capabilities flexible class system. combination non-standard evaluation S4 classes, hope achieve structured modular way expressing optimization problems clinical trials integrates nicely interactive workflow. feel step-wise problem formulation via creation modular intermediate objects, can explored modified separately, encourages exploration different options. Reliability: crux open-source software development clinical trials achieving demonstrable validation. Potential users need convinced software quality need able comply respective validation requirements often require ability produce validation report. burden typically results innovative software used - simply validation effort stemmed. address issue extensive unit test suite companion validation report (cf. Section 7). Extensibility: want impose particular choice scores constraints promote particular notion optimality clinical trial designs. cases composition existing scores sufficient, object-oriented approach adoptr facilitates definition custom scores constraints seamlessly integrate remainder package.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:structure","dir":"Articles","previous_headings":"","what":"Adoptr’s structure","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"package adoptr based R’s S4 class system. allows use multiple dispatch classes multiple arguments method. section, central components adoptr described briefly. following figure gives structural overview main classes adoptr. compute optimal designs, object class UnconditionalScore must defined objective criterion. adoptr distinguishes ConditionalScores UnconditionalScores (cf. Section 2). Scores can evaluated using method evaluate. unconditional scores, method requires Score object TwoStageDesign object, conditional scores (like conditional power), also requires interim outcome \\(x_1\\). Note ConditionalScore \\(S(\\mathcal{D}|X_1=x_1)\\) can converted UnconditionalScore \\(S(\\mathcal{D}) = \\boldsymbol{E}\\big[S(\\mathcal{D}|X_1)\\big]\\) using method expected. two widely used conditional scores pre-implemented ConditionalPower ConditionalSampleSize. unconditional counterparts Power ExpectedSampleSize. predefined unconditional scores MaximumSampleSize, evaluating maximum sample size, N1, measuring first-stage sample size, AverageN2, evaluating average stage-two sample size (improper prior). scores may used regularization variable stage-two sample sizes high stage-one sample size penalized. Users free define Scores (cf. vignette ‘Defining New Scores’ (Kunzmann Pilz 2020)). Moreover, different Scores can composed single one function composite (cf. Section 6.3). conditional unconditional scores can also used define constraints - common case constraints power maximal type one error rate. function minimize takes unconditional score objective set constraints optimizes design parameters. adoptr, different kinds designs implemented. frequently applied case TwoStageDesign, .e., design one interim analysis sample size function varies interim test statistic. Another option subclass GroupSequentialDesign restricts sample size function continuation region single number, .e., \\({n_2(x_1) = n_2\\ \\forall x_1\\[\\,c_1^f, c_1^e\\,]}\\). Additionally, adoptr supports computation optimal OneStageDesigns, .e., designs without interim analysis. Technically, one-stage designs implemented subclasses TwoStageDesign since can viewed limiting case \\(n_2\\equiv0\\) \\(c_1^f=c_1^e\\). Hence, methods implemented TwoStageDesigns also work GroupSequentialDesigns OneStageDesigns. Users can chose keep elements design fixed optimization using methods make_fixed (cf. Section 6.5). joint data distribution adoptr consists two elements. distribution test statistic specified object class DataDistribution. Currently, three options Normal, Binomial, Student implemented. logical variable two_armed allows differentiation one- two-armed trials. Furthermore, adoptr supports prior distributions effect size. can PointMassPriors (cf. Section 6.1) well ContinuousPriors (cf. Section 6.2). following section, hands examples demonstrate capabilities adoptr syntax.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:standard_case","dir":"Articles","previous_headings":"Examples","what":"Standard case","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"Consider case randomized controlled clinical trial efficacy demonstrated terms superiority treatment placebo respect population mean difference \\(\\theta\\) outcome. Let null hypothesis \\(\\mathcal{H}_0:\\theta\\leq 0\\). Assume maximal type one error rate controlled one-sided level \\(\\alpha=2.5\\%\\) minimal power \\(90\\%\\) point alternative \\(\\theta_1=0.3\\) deemed necessary. simplicity’s sake, assume \\(\\sigma^2=1\\) without loss generality. required sample size one-stage design analysis one-sided two-sample \\(t\\)-test roughly 235 per group. Using adoptr, two-stage design minimizing expected sample size alternative hypothesis can derived situation. First, data distribution specified normal. two_armed parameter allows switch single-armed two-armed trials. example, use simple point priors null alternative hypotheses. hypotheses corresponding scores (power values) can specified : Power score requires data distribution prior specified. example, choose PointMassPriors entire probability mass \\(1\\) single point, null hypothesis \\(\\theta = 0\\) compute type one error rate, alternative hypothesis \\(\\theta = 0.3\\) compute power. objective function expected sample size alternative. Since adoptr internally relies COBYLA implementation nloptr, initial design required. heuristic initial choice provided function get_initial_design. based fixed design fulfills constraints type one error rate power. type design (two-stage, group-sequential, one-stage) data distribution defined. Gaussian quadrature used optimization, one also specify order integration rule, .e., number pivot points early stopping futility early stopping efficacy. practice, order 7 turned sufficiently flexible obtain valid results (data shown). easy check initial design fulfill constraints (minimal power 90% maximal type one error rate 2.5%) equality evaluating respective scores: Alternatively, one might also evaluate constraint object directly via constraint objects normalized form \\(h(\\mathcal{D}) \\leq 0\\) (unconditional) \\(h(\\mathcal{D}, x_1) \\leq 0\\) (conditional \\(X_1=x_1\\)). Calling evaluate constraint object simply returns left-hand side inequality. actual optimization started invoking minimize modular structure problem specification intended facilitate inspection modification individual components. call minimize() designed close possible mathematical formulation optimization problem returns optimized design (opt1$design) well full nloptr return value details optimization procedure (opt1$nloptr_return). summary method objects class TwoStageDesign available quickly evaluate set ConditionalScores conditional power well UnconditionalScores power expected sample size. adoptr also implements default plot method overall sample size stage-two critical value functions first-stage test statistic \\(x_1\\). plot method also accepts additional ConditionalScores conditional power. Calling plot method produces several plots interim test statistic \\(x_1\\) \\(x\\)-axis respective function \\(y\\)-axis. Note slightly bent shape \\(c_2(\\cdot)\\) function. two-stage designs based inverse-normal combination function, \\(c_2(\\cdot)\\) linear definition. Since optimal shape \\(c_2(\\cdot)\\) linear (almost), inverse-normal combination methods slightly less efficient (cf. Pilz et al. (2019) detailed discussion issue).","code":"R> datadist <- Normal(two_armed = TRUE) R> null        <- PointMassPrior(theta = .0, mass = 1.0) R> alternative <- PointMassPrior(theta = .3, mass = 1.0) R> power       <- Power(dist = datadist, prior = alternative) R> toer        <- Power(dist = datadist, prior = null) R> mss         <- MaximumSampleSize() R> ess <- ExpectedSampleSize(dist = datadist, prior = alternative) R> initial_design <- get_initial_design(theta = 0.3, alpha = 0.025, +                                       beta = 0.1, type = \"two-stage\", +                                       dist = datadist, order = 7) R> evaluate(toer, initial_design) R> evaluate(power, initial_design) R> evaluate(toer  <= .025, initial_design) R> evaluate(power >= .9, initial_design) R> opt1 <- minimize(ess, subject_to(power >= 0.9, toer  <= 0.025), +                   initial_design) R> cp <- ConditionalPower(dist = datadist, prior = alternative) R> summary(opt1$design, \"Power\" = power, \"ESS\" = ess, \"CP\" = cp) R> plot(opt1$design, `Conditional power` = cp)"},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:uncertainty","dir":"Articles","previous_headings":"Examples","what":"Optimization under uncertainty","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"adoptr limited point priors also supports arbitrary continuous prior distributions. Consider situation now assume prior effect size given much realistic truncated normal distribution mean \\(0.3\\) standard deviation \\(0.1\\), .e., \\(\\theta\\sim\\mathcal{N}_{[-1, 1]}(0.3, 0.1^2)\\). order integration set 25 obtain precise results. objective function expected sample size prior replace power expected power \\[ \\boldsymbol{E} \\Big[ \\boldsymbol{Pr}_\\theta\\big[X_2>c_2(X_1)\\big] \\, \\Big| \\, \\theta \\geq 0.1 \\Big] \\] expected power given relevant effect (define minimal relevant effect \\(0.1\\)). score can defined adoptr first conditioning prior. optimal design point prior achieves expected power optimal design truncated normal prior fulfilling expected power constraint given Note increased complexity problem requires larger maximal number iterations underlying optimization procedure. adoptr exposes nloptr options via argument opts. cases maximal number iterations exhausted, warning thrown. expected sample size prior obtained optimal design equals . shows increased uncertainty \\(\\theta\\) requires larger sample sizes fulfill expected power constraint since expected sample size continuous prior considered section optimal design derived point alternative (see Section 6.1) .","code":"R> prior <- ContinuousPrior( +    pdf     = function(theta) dnorm(theta, mean = .3, sd = .1), +    support = c(-1, 1), +    order   = 25) R> ess <- ExpectedSampleSize(dist = datadist, prior = prior) R> epower <- Power(dist = datadist, prior = condition(prior, c(.1, 1))) R> evaluate(epower, opt1$design) R> opt2 <- minimize(ess, subject_to(epower >= 0.9, toer <= 0.025), +                   initial_design, +                   opts = list(algorithm = \"NLOPT_LN_COBYLA\", +                               xtol_rel = 1e-5, maxeval = 20000))"},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:utility_maximization","dir":"Articles","previous_headings":"Examples","what":"Utility maximization and composite scores","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"adoptr also supports composite scores. can used derive utility maximizing designs defining objective function combining expected power expected sample size instead imposing hard constraint expected power. example, situation one interested utility-maximizing design. , consider utility function \\[ u(\\mathcal{D}) := 200000\\, \\boldsymbol{E} \\Big[ \\boldsymbol{Pr}_\\theta\\big[X_2>c_2(X_1)\\big] \\, \\Big| \\, \\theta \\geq 0.1 \\Big] - \\boldsymbol{E}\\Big[n(X_1)^2\\Big], \\] thus allowing direct trade-power sample size. , expected sample size chosen practitioner might prefer flatter sample size curves. can achieved expected squared sample size penalizing large sample sizes stronger low sample sizes. Furthermore, longer strict expected power constraint expected power becomes part utility function allows direct trade-two quantities. can interpreted pricing mechanism (cf. Kunzmann Kieser (2020)): Every additional percent point expected power (positive) value \\(\\$ 2'000\\) increase \\(\\boldsymbol{E}\\big[n(X_1)^2\\big]\\) \\(1\\) incurs costs \\(\\$ 1\\). goal compute design maximizing overall utility defined utility function \\(u(\\mathcal{D})\\) (equivalently minimize costs). composite score can defined via valid numerical R expression score objects. start defining score expected quadratic sample size minimizing corresponding negative utility without hard expected power constraint. expected power design three optimal designs computed far depicted joint plot. design using continuous prior requires higher sample sizes due higher uncertainty \\(\\theta\\). utility maximization approach results similar shapes \\(n(\\cdot)\\) \\(c_2(\\cdot)\\) constraint optimization. However, sample sizes lower due design’s lower power possible allowing trade-expected power expected sample size. particular, maximal sample size utility-based design equals distinctly smaller case hard power constraint point prior (maximal sample size: ) continuous prior (maximal sample size: ).","code":"R> `n(X_1)`      <- ConditionalSampleSize() R> `E[n(X_1)^2]` <- expected(composite({`n(X_1)`^2}), +                            data_distribution = datadist, +                            prior = prior) R> opt3 <- minimize(composite({`E[n(X_1)^2]` - 200000*epower}), +                   subject_to(toer <= 0.025), initial_design) R> evaluate(epower, opt3$design)"},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:CP_constraint","dir":"Articles","previous_headings":"Examples","what":"Conditional power constraint","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"adoptr also allows incorporation hard constraints conditional scores conditional power. Conditional power constraints intuitively sensible make sure trial continues second stage maintains high chance rejecting null hypothesis end. example, return case point prior effect size. , power derived expected score corresponding conditional power. conditional power constraint added exactly way unconditional constraints. Comparing optimal design computed constraints without conditional power constraint (cf. beginning chapter), optimal design additional constraint requires larger sample sizes regions conditional power usually given threshold. Overall, additional constraint reduces feasible solution space consequently increases expected sample size ( conditional power constraint vs. without). example demonstrates, additional binding conditional constraints come costs global optimality. Whether loss unconditional performance outweighed appealing conditional properties must decided case case basis.","code":"R> prior <- PointMassPrior(theta = .3, mass = 1.0) R> ess   <- ExpectedSampleSize(dist = datadist, prior = prior) R> cp    <- ConditionalPower(dist = datadist, prior = prior) R> power <- expected(cp, data_distribution = datadist, prior = prior) R> opt4 <- minimize(ess, subject_to(toer <= 0.025, power >= 0.9, cp >= 0.8), +                   initial_design)"},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:make_fixed","dir":"Articles","previous_headings":"Examples","what":"Keeping design parameters fixed","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"clinical practice, non-statistical considerations may impose direct constraints design parameters. instance, sponsor might subject logistical constraints render necessary design trial specific stage one sample size. Returning standard case discussed Section 6.1, assume stage-one per-group sample size exactly 80 individuals per group required (\\(n_1 = 80\\)) instead optimal value $n_1^* = $. Furthermore, assume sponsor wants stop early futility negative effect size interim analysis, .e., \\(c_1^f = 0\\). adoptr supports considerations allowing fix specific values design: ‘fixed’ parameter kept constant optimization. Note also possible ‘un-fix’ parameters using make_tunable function. following figure visually compares original design new, restricted design. designs qualitatively similar, fixing \\(n_1\\) \\(c_1^f\\) come price slightly increased expected sample size ( compared less restricted case).","code":"R> initial_design@n1  <- 80 R> initial_design@c1f <- 0 R> initial_design     <- make_fixed(initial_design, n1, c1f) R> opt5 <- minimize(ess, subject_to(toer <= 0.025, power >= 0.9), +                   initial_design)"},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:validation","dir":"Articles","previous_headings":"","what":"Validation concept","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"conduct analysis clinical trials highly regulated process. essential requirement put forward Title 21 CRF (code federal regulations) Part 11 need validate software used work produce records (US Food Drug Administration others 2003). exact scope regulations CRF 11 sometimes difficult assess, always clear regulations apply R packages used production environment (R Foundation Statistical Computing 2013). Irrespective applicability CRF 11 adoptr, design clinical trial undoubtedly crucial package authors provide extensive evidence correctness package functionality. Additionally, evidence easily accessible human-readable. latter requirement consequence fact , following CRF 11 remarks R Foundation Statistical Computing (2013), ‘validated R-package’ exist since validation process must always implemented responsible user. facilitate process validation much possible, adoptr implements following measures: Open-source development: entire development adoptr organized around public GitHub.com repository (https://github.com/optad/adoptr). Anybody can freely download source code, browse development history, raise issues, contribute code base opening pull requests. CRAN releases: Regular CRAN (CRAN 2020) releases updated versions maximize visibility add additional layer testing quality control. New features can implemented tested (public) development version GitHub pushing new releases CRAN. Unit testing: adoptr implements extensive test suite using package testthat (H. Wickham, R Studio, R Core Team (2018), H. Wickham (2011)) allows spotting new errors early development localizing quickly. Together continuous integration (cf. ), helps improve quality speeds development process. Continuous Integration / Continuous Deployment: adoptr makes extensive use continuous integration deployment services GitHub Actions (GitHub.com 2021). new commit public GitHub.com repository immediately run automated testing pipeline. Merges main branch possible tests passed successfully contributor reviewed approved changes (‘branch protection system’). Continuous deployment allows automatically updating code-coverage statistics (cf. ) --date online documentation (cf. ). Coverage analyses: document extent test suite covers package code, adoptr relies codecov (Codecov LLC 2020) online service conjunction covr package (Hester 2019). provides statistics proportion lines visited least testing (currently 100%) enables easy online publication results. Online documentation: Beyond standard documentation generated using roxygen2 (Hadley Wickham et al. 2019), also make use pkgdown (H. Wickham Hesselberth 2019) package free GitHub pages service publish static html version documentation online https://optad.github.io/adoptr/. includes function reference vignettes consistent easily accessible format. online documentation experience improved integration full-text docsearch engine (https://www.algolia.com/ref/docsearch). Extended validation report: limits can done standard unit testing framework within package (cf. https://cran.r-project.org/web/packages/policies.html). Long-running test suites also hinder active development strict continuous integration continuous deployment (CI/CD) workflow since changes main branch require passing automated tests. , therefore, decided restrict internal unit tests bare minimum clear focus coverage technical integrity package. demonstrate correctness results larger set examples comparison existing packages rpact, implemented external ‘validation report’ (sources: https://github.com/kkmann/adoptr-validation-report, current report: https://kkmann.github.io/adoptr-validation-report/) using bookdown (Xie (2019), Xie (2016)) package. report uses CI/CD daily rebuilds automatically deploy report corresponding current CRAN-hosted version package. Within report, still use testthat conduct formal tests. case tests fails, build report fail, maintainers get notified, status indicator repository changes. Validating software employed may well much work developing first place. opaque requirements lack adequate tools automate validation tasks major hurdle academic developers address validation issues. additional work, however, worth since improves quality also facilitates collaboration makes easier promote packages real-world use.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"future-work","dir":"Articles","previous_headings":"","what":"Future work","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"main motivation implementing adoptr R fact far common programming language used target audience. Note, however, using R generic nonlinear constraint optimization problems leads performance bottleneck since currently stable efficient way obtaining gradient information generic, user-defined functions. Since one design principles adoptr extensibility, ability support custom objective functions central. R, implies one resort either finite differences approximation first- second-order derivatives completely gradient-free optimizer COBYLA. experiments, found COBYLA far stable finite-differences augmented Lagrangian method (data shown). Still, problems, convergence using COBYLA rather slow. interesting alternative R nloptr therefore Julia (Bezanson et al. 2017) JuMP framework numerical programming (Lubin Dunning 2015). framework allows interfacing generic nonlinear solvers via common interface , leveraging Julia’s excellent automatic-differentiation capabilities, able provide fast precise (second-order) gradient information user-defined objective functions.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"first two authors contributed equally manuscript. work partly supported Deutsche Forschungsgemeinschaft Grant number KI 708/4-1.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/articles/composite-scores.html","id":"functional-composition","dir":"Articles","previous_headings":"","what":"Functional Composition","title":"Composite Scores","text":"Composite scores restricted linear operations support valid numerical expression: Even control flow supported: real constraint expression must vectorized.","code":"cs <- composite({log(css) - 50*sin(cp)}) evaluate(cs, design, c(0, .5, 1)) #> [1] -36.39139 -36.53500 -36.55095 cs <- composite({   res <- 0   for (i in 1:3) {     res <- res + css   }   res }) evaluate(cs, design, c(0, .5, 1)) #> [1] 750 750 750"},{"path":"https://optad.github.io/adoptr/articles/conditional-scores.html","id":"unconditional-scores-in-adoptr","dir":"Articles","previous_headings":"","what":"(Un)conditional Scores in adoptr","title":"Conditional Scores and Constraints","text":"two fundamental ways scoring two-stage design: First, one may assess performance observing data, .e., planning stage. Classical examples scores power, type-one-error rate, expected sample size. , however, second perspective. observing stage-one outcome, one might inclined consider conditional properties design. prominent example conditional power (probability reject null alternative given stage-one outcome). consider following example design  adoptr, scores instances respective score class. important ones : ConditionalScore, UnconditionalScore, IntegralScore. object class ConditionalScore can evaluate design particular stage-one outcome. ConditionalScore function \\(s(\\mathcal{D}, x_1)\\) evaluating design \\(\\mathcal{D}\\) stage-one outcome \\(X_1 = x_1\\). conditional scores might depend data distribution (conditional power) others (conditional sample size). Conditional score evaluation completely vectorized: Conditional scores can also plotted directly given design including plot() call.  conditional score can integrated respect prior data distribution obtain unconditional score. Note conditional scores depend specification distributions (e.g., conditional power) arguments must consistent! resulting score class IntegralScore, specific subclass UnconditionalScore evaluates designs independent particular \\(x_1\\), .e., unconditionally Power point alternative can obtained forming expected value respect point prior. convenience, include constructor power directly, e.g., variants equivalent give power \\(0.4\\). Similarly, ExpectedSampleSize shorthand constructor expected conditional sample size, .e., overall expected sample size:","code":"design <- TwoStageDesign(     n1        = 100,     c1f       = .0,     c1e       = 2.0,     n2_pivots = rep(150, 5),     c2_pivots = sapply(1 + adoptr:::GaussLegendreRule(5)$nodes, function(x) -x + 2) ) plot(design) uniform_prior <- ContinuousPrior(   function(x) numeric(length(x)) + 1/.2,   support = c(.3, .5) )  cp  <- ConditionalPower(Normal(), uniform_prior) css <- ConditionalSampleSize()  x1  <- c(0, .5, 1) evaluate(cp, design, x1) #> [1] 0.8312538 0.9303985 0.9772962 evaluate(css, design, x1) #> [1] 250 250 250 plot(design, \"Conditional Power\" = cp) ep <- expected(cp, Normal(), uniform_prior) evaluate(ep, design) #> [1] 0.989392 power1 <- expected(   ConditionalPower(Normal(), PointMassPrior(.4, 1.0)),   Normal(), PointMassPrior(.4, 1.0) ) power2 <- Power(Normal(), PointMassPrior(.4, 1.0))  evaluate(power1, design) #> [1] 0.9967857 evaluate(power2, design) #> [1] 0.9967857 ess1 <- expected(ConditionalSampleSize(), Normal(), uniform_prior) ess2 <- ExpectedSampleSize(Normal(), uniform_prior)  evaluate(ess1, design) #> [1] 134.9135 evaluate(ess2, design) #> [1] 134.9135"},{"path":"https://optad.github.io/adoptr/articles/conditional-scores.html","id":"conditional-constraints","dir":"Articles","previous_headings":"","what":"Conditional Constraints","title":"Conditional Scores and Constraints","text":"syntax constraint specification unconditional constraints (power etc.) can used conditional scores (e.g. conditional power) well. Currently, constraints apply continuation area . E.g., imposes constraint minimal conditional power upon continuation. Inter-score comparisons also supported, e.g. enforce conditional power always larger conditional error.","code":"cp >= 0.7 #> -Pr[x2>=c2(x1)|x1] (x1) <= -0.7 for x1 in [c1f,c1e] cp >= ConditionalPower(Normal(), PointMassPrior(0, 1)) #> Pr[x2>=c2(x1)|x1]  - Pr[x2>=c2(x1)|x1] (x1) <= 0 for x1 in [c1f,c1e]"},{"path":"https://optad.github.io/adoptr/articles/working-with-priors.html","id":"discrete-priors","dir":"Articles","previous_headings":"","what":"Discrete priors","title":"Working with priors","text":"simplest supported prior class discrete PointMassPrior priors. specify discrete prior, one simply specifies vector pivot points positive mass vector corresponding probability masses. E.g., consider example point \\(\\delta = 0.1\\) probability mass \\(0.4\\) point \\(\\delta = 0.25\\) mass \\(1 - 0.4 = 0.6\\). details provided methods, see ?DiscretePrior.","code":"disc_prior <- PointMassPrior(c(0.1, 0.25), c(0.4, 0.6))"},{"path":"https://optad.github.io/adoptr/articles/working-with-priors.html","id":"continuous-priors","dir":"Articles","previous_headings":"","what":"Continuous priors","title":"Working with priors","text":"adoptr also supports arbitrary continuous priors support compact intervals. instance, consider prior based truncated normal via: details provided methods, see ?ContinuousPrior.","code":"cont_prior <- ContinuousPrior(   pdf     = function(x) dnorm(x, mean = 0.3, sd = 0.2),    support = c(-2, 3) )"},{"path":"https://optad.github.io/adoptr/articles/working-with-priors.html","id":"conditioning","dir":"Articles","previous_headings":"","what":"Conditioning","title":"Working with priors","text":"practice, important operation conditioning. important implement type one type two error rate constraints. Consider, e.g., case power. Typically, power constraint imposed single point alternative, e.g. using constraint uncertainty true response rate incorporated design, makes sense assume continuous prior \\(\\theta\\). case, prior conditioned power constraint avoid integrating null hypothesis:","code":"Power(Normal(), PointMassPrior(.4, 1)) >= 0.8 #> -Pr[x2>=c2(x1)]  <= -0.8 Power(Normal(), condition(cont_prior, c(0, 3))) >= 0.8 #> -Pr[x2>=c2(x1)]  <= -0.8"},{"path":"https://optad.github.io/adoptr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kevin Kunzmann. Author, copyright holder. Maximilian Pilz. Author, maintainer. Jan Meis. Author. Nico Bruder. Author.","code":""},{"path":"https://optad.github.io/adoptr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kunzmann K, Pilz M, Herrmann C, Rauch G, Kieser M (2021). “adoptr Package: Adaptive Optimal Designs Clinical Trials R.” Journal Statistical Software, 98(9), 1–21. doi:10.18637/jss.v098.i09.","code":"@Article{,   title = {The {adoptr} Package: Adaptive Optimal Designs for Clinical Trials in {R}},   author = {Kevin Kunzmann and Maximilian Pilz and Carolin Herrmann and Geraldine Rauch and Meinhard Kieser},   journal = {Journal of Statistical Software},   year = {2021},   volume = {98},   number = {9},   pages = {1--21},   doi = {10.18637/jss.v098.i09}, }"},{"path":"https://optad.github.io/adoptr/index.html","id":"adoptr-","dir":"","previous_headings":"","what":"Adaptive Optimal Two-Stage Designs","title":"Adaptive Optimal Two-Stage Designs","text":"Adaptive optimal two-stage designs clinical trials one two arms. details core theoretical background, see: Pilz M, Kunzmann K, Herrmann C, Rauch G, Kieser M. variational approach optimal two-stage designs. Statistics Medicine. 2019;38(21):4159–4171. https://doi.org/10.1002/sim.8291","code":""},{"path":"https://optad.github.io/adoptr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Adaptive Optimal Two-Stage Designs","text":"Install latest CRAN release via development version directly GitHub :","code":"install.packages(\"adoptr\") devtools::install_github(\"optad/adoptr\")"},{"path":"https://optad.github.io/adoptr/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Adaptive Optimal Two-Stage Designs","text":"documentation hosted https://optad.github.io/adoptr.","code":""},{"path":"https://optad.github.io/adoptr/index.html","id":"validation-report","dir":"","previous_headings":"","what":"Validation Report","title":"Adaptive Optimal Two-Stage Designs","text":"provide extensive validation report adoptr implemented using bookdown package. sources available https://github.com/kkmann/adoptr-validation-report last build version hosted https://kkmann.github.io/adoptr-validation-report.","code":""},{"path":"https://optad.github.io/adoptr/reference/AverageN2-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Regularization via L1 norm — AverageN2-class","title":"Regularization via L1 norm — AverageN2-class","text":"Implements L1-norm design's stage-two sample size function. average stage-two sample size without weighting data distribution computed. can interpreted integration unifrom prior continuation region.","code":""},{"path":"https://optad.github.io/adoptr/reference/AverageN2-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regularization via L1 norm — AverageN2-class","text":"","code":"AverageN2(label = NA_character_)  # S4 method for AverageN2,TwoStageDesign evaluate(s, design, optimization = FALSE, subdivisions = 10000L, ...)"},{"path":"https://optad.github.io/adoptr/reference/AverageN2-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regularization via L1 norm — AverageN2-class","text":"label object label (string) s Score object design object optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. subdivisions number subdivisions use adaptive integration (affects non-optimization code) ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/AverageN2-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regularization via L1 norm — AverageN2-class","text":"object class AverageN2","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/AverageN2-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regularization via L1 norm — AverageN2-class","text":"","code":"avn2 <- AverageN2()  evaluate(    AverageN2(),    TwoStageDesign(100, 0.5, 1.5, 60.0, 1.96, order = 5L) ) # 60 #> [1] 60"},{"path":"https://optad.github.io/adoptr/reference/BinomialDataDistribution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Binomial data distribution — Binomial-class","title":"Binomial data distribution — Binomial-class","text":"Implements normal approximation test rates. reponse rate control group, rC, specified rate_control. null hypothesis : rE ≤ rC, rE denotes response rate invervention group. tested alternative rE > rC. test statistic given X1 = √n (rE - rC) / √(2  r0 (1-r0)), r0 denotes mean rE rC two-armed case, rE one-armed case.#' priors defined rate difference rE - rC.","code":""},{"path":"https://optad.github.io/adoptr/reference/BinomialDataDistribution-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binomial data distribution — Binomial-class","text":"","code":"Binomial(rate_control, two_armed = TRUE)  # S4 method for Binomial quantile(x, probs, n, theta, ...)  # S4 method for Binomial,numeric simulate(object, nsim, n, theta, seed = NULL, ...)"},{"path":"https://optad.github.io/adoptr/reference/BinomialDataDistribution-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binomial data distribution — Binomial-class","text":"rate_control assumed response rate control group two_armed logical indicating two-armed trial regarded x outcome probs vector probabilities n sample size theta distribution parameter ... optional arguments object object class Binomial nsim number simulation runs seed random seed","code":""},{"path":"https://optad.github.io/adoptr/reference/BinomialDataDistribution-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Binomial data distribution — Binomial-class","text":"Note simulate class Binomial simulates normal approximation test statistic.","code":""},{"path":"https://optad.github.io/adoptr/reference/BinomialDataDistribution-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Binomial data distribution — Binomial-class","text":"rate_control cf. parameter 'rate_control'","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/BinomialDataDistribution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Binomial data distribution — Binomial-class","text":"","code":"datadist <- Binomial(rate_control = 0.2, two_armed = FALSE)"},{"path":"https://optad.github.io/adoptr/reference/ConditionalPower-class.html","id":null,"dir":"Reference","previous_headings":"","what":"(Conditional) Power of a Design — ConditionalPower-class","title":"(Conditional) Power of a Design — ConditionalPower-class","text":"score evaluates P[X2 > c2(design, X1) | X1 = x1]. Note distribution X2 posterior predictive observing X1 = x1.","code":""},{"path":"https://optad.github.io/adoptr/reference/ConditionalPower-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"(Conditional) Power of a Design — ConditionalPower-class","text":"","code":"ConditionalPower(dist, prior, label = \"Pr[x2>=c2(x1)|x1]\")  Power(dist, prior, label = \"Pr[x2>=c2(x1)]\")  # S4 method for ConditionalPower,TwoStageDesign evaluate(s, design, x1, optimization = FALSE, ...)"},{"path":"https://optad.github.io/adoptr/reference/ConditionalPower-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"(Conditional) Power of a Design — ConditionalPower-class","text":"dist univariate distribution object prior Prior object label object label (string) s Score object design object x1 stage-one test statistic optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. ... optional arguments","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/ConditionalPower-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"(Conditional) Power of a Design — ConditionalPower-class","text":"","code":"prior <- PointMassPrior(.4, 1) cp <- ConditionalPower(Normal(), prior) evaluate(    cp,    TwoStageDesign(50, .0, 2.0, 50, 2.0, order = 5L),    x1 = 1 ) #> [1] 0.5 # these two are equivalent: expected(cp, Normal(), prior) #> E[Pr[x2>=c2(x1)|x1]]<Normal<two-armed>;PointMass<0.40>>  Power(Normal(), prior) #> Pr[x2>=c2(x1)]"},{"path":"https://optad.github.io/adoptr/reference/ConditionalSampleSize-class.html","id":null,"dir":"Reference","previous_headings":"","what":"(Conditional) Sample Size of a Design — ConditionalSampleSize-class","title":"(Conditional) Sample Size of a Design — ConditionalSampleSize-class","text":"score simply evaluates n(d, x1) design d first-stage outcome x1. data distribution prior relevant integrated.","code":""},{"path":"https://optad.github.io/adoptr/reference/ConditionalSampleSize-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"(Conditional) Sample Size of a Design — ConditionalSampleSize-class","text":"","code":"ConditionalSampleSize(label = \"n(x1)\")  ExpectedSampleSize(dist, prior, label = \"E[n(x1)]\")  # S4 method for ConditionalSampleSize,TwoStageDesign evaluate(s, design, x1, optimization = FALSE, ...)"},{"path":"https://optad.github.io/adoptr/reference/ConditionalSampleSize-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"(Conditional) Sample Size of a Design — ConditionalSampleSize-class","text":"label object label (string) dist univariate distribution object prior Prior object s Score object design object x1 stage-one test statistic optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. ... optional arguments","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/ConditionalSampleSize-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"(Conditional) Sample Size of a Design — ConditionalSampleSize-class","text":"","code":"design <- TwoStageDesign(50, .0, 2.0, 50, 2.0, order = 5L) prior  <- PointMassPrior(.4, 1)  css   <- ConditionalSampleSize() evaluate(css, design, c(0, .5, 3)) #> [1] 100 100  50  ess   <- ExpectedSampleSize(Normal(), prior)  # those two are equivalent evaluate(ess, design) #> [1] 73.86249 evaluate(expected(css, Normal(), prior), design) #> [1] 73.86249"},{"path":"https://optad.github.io/adoptr/reference/Constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Formulating Constraints — Constraints","title":"Formulating Constraints — Constraints","text":"Conceptually, constraints work similar scores (score can put constraint). Currently,  constraints form 'score <=/>= x', 'x <=/>= score' 'score <=/>= score' admissible.","code":""},{"path":"https://optad.github.io/adoptr/reference/Constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Formulating Constraints — Constraints","text":"","code":"# S4 method for Constraint,TwoStageDesign evaluate(s, design, optimization = FALSE, ...)  # S4 method for ConditionalScore,numeric &lt;=(e1, e2)  # S4 method for ConditionalScore,numeric &gt;=(e1, e2)  # S4 method for numeric,ConditionalScore &lt;=(e1, e2)  # S4 method for numeric,ConditionalScore &gt;=(e1, e2)  # S4 method for ConditionalScore,ConditionalScore &lt;=(e1, e2)  # S4 method for ConditionalScore,ConditionalScore &gt;=(e1, e2)  # S4 method for UnconditionalScore,numeric &lt;=(e1, e2)  # S4 method for UnconditionalScore,numeric &gt;=(e1, e2)  # S4 method for numeric,UnconditionalScore &lt;=(e1, e2)  # S4 method for numeric,UnconditionalScore &gt;=(e1, e2)  # S4 method for UnconditionalScore,UnconditionalScore &lt;=(e1, e2)  # S4 method for UnconditionalScore,UnconditionalScore &gt;=(e1, e2)"},{"path":"https://optad.github.io/adoptr/reference/Constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Formulating Constraints — Constraints","text":"s Score object design object optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. ... optional arguments e1 left hand side (score numeric) e2 right hand side (score numeric)","code":""},{"path":"https://optad.github.io/adoptr/reference/Constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Formulating Constraints — Constraints","text":"object class Constraint","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/Constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Formulating Constraints — Constraints","text":"","code":"design <- OneStageDesign(50, 1.96)  cp     <- ConditionalPower(Normal(), PointMassPrior(0.4, 1)) pow    <- Power(Normal(), PointMassPrior(0.4, 1))  # unconditional power constraint constraint1 <- pow >= 0.8 evaluate(constraint1, design) #> [1] 0.2840466  # conditional power constraint constraint2 <- cp  >= 0.7 evaluate(constraint2, design, .5) #> [1] 0.7 constraint3 <- 0.7 <= cp # same as constraint2 evaluate(constraint3, design, .5) #> [1] 0.7"},{"path":"https://optad.github.io/adoptr/reference/ContinuousPrior-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Continuous univariate prior distributions — ContinuousPrior-class","title":"Continuous univariate prior distributions — ContinuousPrior-class","text":"ContinuousPrior sub-class Prior implementing generic representation continuous prior distributions compact interval real line.","code":""},{"path":"https://optad.github.io/adoptr/reference/ContinuousPrior-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Continuous univariate prior distributions — ContinuousPrior-class","text":"","code":"ContinuousPrior(   pdf,   support,   order = 10,   label = NA_character_,   tighten_support = FALSE,   check_normalization = TRUE )"},{"path":"https://optad.github.io/adoptr/reference/ContinuousPrior-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Continuous univariate prior distributions — ContinuousPrior-class","text":"pdf vectorized univariate PDF function support numeric vector length two bounds compact interval pdf positive. order integer, integration order employed Gaussian quadrature integration rule evaluate scores. Automatically set length(n2_pivots) length(n2_pivots) == length(c2_pivots) > 1, otherwise c2 n2 taken constant stage-two replicated match number pivots specified order label object label (string) tighten_support logical indicating support tightened check_normalization logical indicating checked pdf defines density.","code":""},{"path":"https://optad.github.io/adoptr/reference/ContinuousPrior-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Continuous univariate prior distributions — ContinuousPrior-class","text":"pdf cf. parameter 'pdf' support cf. parameter 'support' pivots normalized pivots integration rule ([-1, 1]) actual pivots scaled support prior weights weights integration rule pivots approximating integrals delta","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/ContinuousPrior-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Continuous univariate prior distributions — ContinuousPrior-class","text":"","code":"ContinuousPrior(function(x) 2*x, c(0, 1)) #> ContinuousPrior<[0,1]>"},{"path":"https://optad.github.io/adoptr/reference/DataDistribution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Data distributions — DataDistribution-class","title":"Data distributions — DataDistribution-class","text":"DataDistribution abstract class used represent distribution sufficient statistic x given sample size n single parameter value theta.","code":""},{"path":"https://optad.github.io/adoptr/reference/DataDistribution-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data distributions — DataDistribution-class","text":"x outcome n sample size theta distribution parameter ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/DataDistribution-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data distributions — DataDistribution-class","text":"abstraction layer allows representation t-distributions (unknown variance), normal distribution (known variance), normal approximation binary endpoint. Currently, two implemented versions Normal-class Binomial-class. logical option two_armed allows decide whether one-arm two-arm (default) design computed. case two-arm design sample sizes per group.","code":""},{"path":"https://optad.github.io/adoptr/reference/DataDistribution-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Data distributions — DataDistribution-class","text":"two_armed Logical indicates two-arm design assumed.","code":""},{"path":"https://optad.github.io/adoptr/reference/DataDistribution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data distributions — DataDistribution-class","text":"","code":"normaldist   <- Normal(two_armed = FALSE) binomialdist <- Binomial(rate_control = .25, two_armed = TRUE)"},{"path":"https://optad.github.io/adoptr/reference/GroupSequentialDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Group-sequential two-stage designs — GroupSequentialDesign-class","title":"Group-sequential two-stage designs — GroupSequentialDesign-class","text":"Group-sequential designs sub-class TwoStageDesign class constant stage-two sample size. See TwoStageDesign slot details. group-sequential design can converted fully flexible TwoStageDesign (see examples section).","code":""},{"path":"https://optad.github.io/adoptr/reference/GroupSequentialDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group-sequential two-stage designs — GroupSequentialDesign-class","text":"","code":"GroupSequentialDesign(n1, c1f, c1e, n2_pivots, c2_pivots, order = NULL, ...)  # S4 method for GroupSequentialDesign TwoStageDesign(n1, ...)"},{"path":"https://optad.github.io/adoptr/reference/GroupSequentialDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group-sequential two-stage designs — GroupSequentialDesign-class","text":"n1 stage one sample size GroupSequentialDesign object convert (overloaded TwoStageDesign) c1f early futility stopping boundary c1e early efficacy stopping boundary n2_pivots numeric length one, stage-two sample size c2_pivots numeric vector, stage-two critical values integration pivot points order Gaussian uadrature rule use integration, set length(c2_pivots) NULL, otherwise first value c2_pivots repeated 'order'-times. ... optional arguments","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/GroupSequentialDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group-sequential two-stage designs — GroupSequentialDesign-class","text":"","code":"design <- GroupSequentialDesign(25, 0, 2, 25, c(1, 1.5, 2.5)) summary(design) #> GroupSequentialDesign: n1 =  25  #>            futility |      continue     | efficacy #>        x1:    -0.00 |  0.23  1.00  1.77 |  2.00 #>    c2(x1):     +Inf | +1.00 +1.50 +2.50 |  -Inf #>    n2(x1):        0 |    25    25    25 |     0 #>   TwoStageDesign(design) #> TwoStageDesign<n1=25;0.0<=x1<=2.0:n2=25>"},{"path":"https://optad.github.io/adoptr/reference/MaximumSampleSize-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum Sample Size of a Design — MaximumSampleSize-class","title":"Maximum Sample Size of a Design — MaximumSampleSize-class","text":"score evaluates max(n(d)) design d.","code":""},{"path":"https://optad.github.io/adoptr/reference/MaximumSampleSize-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum Sample Size of a Design — MaximumSampleSize-class","text":"","code":"MaximumSampleSize(label = \"max(n(x1))\")  # S4 method for MaximumSampleSize,TwoStageDesign evaluate(s, design, optimization = FALSE, ...)"},{"path":"https://optad.github.io/adoptr/reference/MaximumSampleSize-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum Sample Size of a Design — MaximumSampleSize-class","text":"label object label (string) s Score object design object optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. ... optional arguments","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/MaximumSampleSize-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum Sample Size of a Design — MaximumSampleSize-class","text":"","code":"design <- TwoStageDesign(50, .0, 2.0, 50, 2.0, order = 5L) mss    <- MaximumSampleSize() evaluate(mss, design) #> [1] 100"},{"path":"https://optad.github.io/adoptr/reference/N1-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Regularize n1 — N1-class","title":"Regularize n1 — N1-class","text":"N1 class computes n1 value design. can used score minimize.","code":""},{"path":"https://optad.github.io/adoptr/reference/N1-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regularize n1 — N1-class","text":"","code":"N1(label = NA_character_)  # S4 method for N1,TwoStageDesign evaluate(s, design, optimization = FALSE, ...)"},{"path":"https://optad.github.io/adoptr/reference/N1-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regularize n1 — N1-class","text":"label object label (string) s Score object design object optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/N1-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regularize n1 — N1-class","text":"object class N1","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/N1-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regularize n1 — N1-class","text":"","code":"n1_score <- N1()  evaluate(    N1(),    TwoStageDesign(70, 0, 2, rep(60, 6), rep(1.7, 6)) ) # 70 #> [1] 70"},{"path":"https://optad.github.io/adoptr/reference/NormalDataDistribution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Normal data distribution — Normal-class","title":"Normal data distribution — Normal-class","text":"Implements normal data distribution z-values given observed z-value stage size. Standard deviation 1 mean θ √n θ standardized effect size. option two_armed can set decide whether one-arm two-arm design computed.","code":""},{"path":"https://optad.github.io/adoptr/reference/NormalDataDistribution-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normal data distribution — Normal-class","text":"","code":"Normal(two_armed = TRUE)  # S4 method for Normal quantile(x, probs, n, theta, ...)  # S4 method for Normal,numeric simulate(object, nsim, n, theta, seed = NULL, ...)"},{"path":"https://optad.github.io/adoptr/reference/NormalDataDistribution-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normal data distribution — Normal-class","text":"two_armed logical indicating two-armed trial regarded x outcome probs vector probabilities n sample size theta distribution parameter ... optional arguments object object class Normal nsim number simulation runs seed random seed","code":""},{"path":"https://optad.github.io/adoptr/reference/NormalDataDistribution-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Normal data distribution — Normal-class","text":"See DataDistribution-class details.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/NormalDataDistribution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normal data distribution — Normal-class","text":"","code":"datadist <- Normal(two_armed = TRUE)"},{"path":"https://optad.github.io/adoptr/reference/OneStageDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"One-stage designs — OneStageDesign-class","title":"One-stage designs — OneStageDesign-class","text":"OneStageDesign implements one-stage design special case two-stage design, .e. sub-class TwoStageDesign. possible defining n2 = 0, c = c1f = c1e, c2(x1) = ifelse(x1NaN).","code":""},{"path":"https://optad.github.io/adoptr/reference/OneStageDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"One-stage designs — OneStageDesign-class","text":"","code":"OneStageDesign(n, c)  # S4 method for OneStageDesign TwoStageDesign(n1, order = 5L, eps = 0.01, ...)  # S4 method for OneStageDesign plot(x, y, ...)"},{"path":"https://optad.github.io/adoptr/reference/OneStageDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"One-stage designs — OneStageDesign-class","text":"n sample size (stage-one sample size) c rejection boundary (c = c1f = c1e) n1 OneStageDesign object convert, overloaded TwoStageDesign order integer >= 2, default 5; order Gaussian quadrature integration rule use new TwoStageDesign. eps numeric > 0, default = .01; single critical value c must split continuation interval [c1f, c1e]; given c +/- eps. ... optional arguments x design plot y used","code":""},{"path":"https://optad.github.io/adoptr/reference/OneStageDesign-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"One-stage designs — OneStageDesign-class","text":"Note default plot,TwoStageDesign-method method supported OneStageDesign objects.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/OneStageDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"One-stage designs — OneStageDesign-class","text":"","code":"design <- OneStageDesign(30, 1.96) summary(design) #> OneStageDesign: n1 =  30  #>            futility | continue | efficacy #>        x1:     1.96 |   NaN |  1.96 #>    c2(x1):     +Inf |    NA |  -Inf #>    n2(x1):        0 |     0 |     0 #>  design <- TwoStageDesign(design) summary(design) #> TwoStageDesign: n1 =  30  #>            futility |            continue           | efficacy #>        x1:     1.95 |  1.95  1.95  1.96  1.97  1.97 |  1.97 #>    c2(x1):     +Inf | +3.00 +3.00 +0.00 -3.00 -3.00 |  -Inf #>    n2(x1):        0 |     0     0     0     0     0 |     0 #>"},{"path":"https://optad.github.io/adoptr/reference/PointMassPrior-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate discrete point mass priors — PointMassPrior-class","title":"Univariate discrete point mass priors — PointMassPrior-class","text":"PointMassPrior sub-class Prior representing univariate prior discrete set points positive probability mass.","code":""},{"path":"https://optad.github.io/adoptr/reference/PointMassPrior-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariate discrete point mass priors — PointMassPrior-class","text":"","code":"PointMassPrior(theta, mass, label = NA_character_)"},{"path":"https://optad.github.io/adoptr/reference/PointMassPrior-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariate discrete point mass priors — PointMassPrior-class","text":"theta numeric vector pivot points positive prior mass mass numeric vector probability masses pivot points (must sum 1) label object label (string)","code":""},{"path":"https://optad.github.io/adoptr/reference/PointMassPrior-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Univariate discrete point mass priors — PointMassPrior-class","text":"object class PointMassPrior, theta automatically sorted ascending order","code":""},{"path":"https://optad.github.io/adoptr/reference/PointMassPrior-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Univariate discrete point mass priors — PointMassPrior-class","text":"theta cf. parameter 'theta' mass cf. parameter 'mass'","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/PointMassPrior-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariate discrete point mass priors — PointMassPrior-class","text":"","code":"PointMassPrior(c(0, .5), c(.3, .7)) #> PointMass<Pr[0.00]=0.30;Pr[0.50]=0.70>"},{"path":"https://optad.github.io/adoptr/reference/Prior-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate prior on model parameter — Prior-class","title":"Univariate prior on model parameter — Prior-class","text":"Prior object represents prior distribution single model parameter DataDistribution class object. Together prior data-distribution specify class joint distribution test statisic, X, parameter, theta. Currently, adoptr allows simple models single parameter. Implementations PointMassPrior ContinuousPrior available.","code":""},{"path":"https://optad.github.io/adoptr/reference/Prior-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Univariate prior on model parameter — Prior-class","text":"example working priors, see .","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/Prior-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariate prior on model parameter — Prior-class","text":"","code":"disc_prior <- PointMassPrior(c(0.1, 0.25), c(0.4, 0.6))  cont_prior <- ContinuousPrior(   pdf     = function(x) dnorm(x, mean = 0.3, sd = 0.2),   support = c(-2, 3) )"},{"path":"https://optad.github.io/adoptr/reference/Scores.html","id":null,"dir":"Reference","previous_headings":"","what":"Scores — Scores","title":"Scores — Scores","text":"adoptr scores used assess performance design. can done either conditionally observed stage-one outcome unconditionally. Consequently, score objects either class ConditionalScore UnconditionalScore.","code":""},{"path":"https://optad.github.io/adoptr/reference/Scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scores — Scores","text":"","code":"expected(s, data_distribution, prior, ...)  # S4 method for ConditionalScore expected(s, data_distribution, prior, label = NA_character_, ...)  evaluate(s, design, ...)  # S4 method for IntegralScore,TwoStageDesign evaluate(s, design, optimization = FALSE, subdivisions = 10000L, ...)"},{"path":"https://optad.github.io/adoptr/reference/Scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scores — Scores","text":"s Score object data_distribution DataDistribution object prior Prior object ... optional arguments label object label (string) design object optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. subdivisions maximal number subdivisions evaluating integral score using adaptive quadrature (optimization = FALSE)","code":""},{"path":"https://optad.github.io/adoptr/reference/Scores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scores — Scores","text":"return value. Generic description class Score.","code":""},{"path":"https://optad.github.io/adoptr/reference/Scores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Scores — Scores","text":"scores can evaluated design using evaluate method. Note evaluate requires third argument x1 conditional scores (observed stage-one outcome). ConditionalScore can converted UnconditionalScore forming expected value using expected. returned unconditional score class IntegralScore.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/Scores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scores — Scores","text":"","code":"design <- TwoStageDesign(   n1    = 25,   c1f   = 0,   c1e   = 2.5,   n2    = 50,   c2    = 1.96,   order = 7L ) prior <- PointMassPrior(.3, 1)  # conditional cp <- ConditionalPower(Normal(), prior) expected(cp, Normal(), prior) #> E[Pr[x2>=c2(x1)|x1]]<Normal<two-armed>;PointMass<0.30>>  evaluate(cp, design, x1 = .5) #> [1] 0.3227581  # unconditional power <- Power(Normal(), prior) evaluate(power, design) #> [1] 0.3269562 evaluate(power, design, optimization = TRUE) # use non-adaptive quadrature #> [1] 0.3269562"},{"path":"https://optad.github.io/adoptr/reference/StudentDataDistribution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Student's t data distribution — Student-class","title":"Student's t data distribution — Student-class","text":"Implements exact t-distributions instead normal approximation","code":""},{"path":"https://optad.github.io/adoptr/reference/StudentDataDistribution-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Student's t data distribution — Student-class","text":"","code":"Student(two_armed = TRUE)  # S4 method for Student quantile(x, probs, n, theta, ...)  # S4 method for Student,numeric simulate(object, nsim, n, theta, seed = NULL, ...)"},{"path":"https://optad.github.io/adoptr/reference/StudentDataDistribution-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Student's t data distribution — Student-class","text":"two_armed logical indicating two-armed trial regarded x outcome probs vector probabilities n sample size theta distribution parameter ... optional arguments object object class Student nsim number simulation runs seed random seed","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/StudentDataDistribution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Student's t data distribution — Student-class","text":"","code":"datadist <- Student(two_armed = TRUE)"},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Two-stage designs — TwoStageDesign-class","title":"Two-stage designs — TwoStageDesign-class","text":"TwoStageDesign fundamental design class adoptr package. Formally, represent generic two-stage design five-tuple (n1, c1f, c1e, n2(·), c2(·)). , n1 first-stage sample size (per group), c1f c1e boundaries early stopping futility efficacy, respectively. Since trial design two-stage design, elements n2(·) (stage-two sample size) c2(·) (stage-two critical value) functions first-stage outcome X1=x1. X1 denotes first-stage test statistic. brief description definition two-stage designs can read . available methods, see 'See Also' section end page.","code":""},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Two-stage designs — TwoStageDesign-class","text":"","code":"TwoStageDesign(n1, ...)  # S4 method for numeric TwoStageDesign(n1, c1f, c1e, n2_pivots, c2_pivots, order = NULL, ...)  # S4 method for TwoStageDesign summary(object, ..., rounded = TRUE)"},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Two-stage designs — TwoStageDesign-class","text":"n1 stage-one sample size ... optional arguments c1f early futility stopping boundary c1e early efficacy stopping boundary n2_pivots numeric vector, stage-two sample size integration pivot points c2_pivots numeric vector, stage-two critical values integration pivot points order integer, integration order employed Gaussian quadrature integration rule evaluate scores. Automatically set length(n2_pivots) length(n2_pivots) == length(c2_pivots) > 1, otherwise c2 n2 taken constant stage-two replicated match number pivots specified order object object show rounded rounded n-values used?","code":""},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesign-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Two-stage designs — TwoStageDesign-class","text":"summary can used quickly compute display basic facts TwoStageDesign. arbitrary number names UnconditionalScore objects can provided via optional arguments ... included summary displayed using print.","code":""},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Two-stage designs — TwoStageDesign-class","text":"n1 cf. parameter 'n1' c1f cf. parameter 'c1f' c1e cf. parameter 'c1e' n2_pivots vector length 'order' giving values n2 pivot points numeric integration rule c2_pivots vector length order giving values c2 pivot points numeric integration rule x1_norm_pivots normalized pivots integration rule ([-1, 1]) actual pivots scaled interval [c1f, c1e] can obtained internal method adoptr:::scaled_integration_pivots(design) weights weights integration rule x1_norm_pivots approximating integrals x1 tunable named logical vector indicating whether corresponding slot considered tunable parameter (.e. whether can changed optimization via minimize ; cf. make_fixed)","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Two-stage designs — TwoStageDesign-class","text":"","code":"design <- TwoStageDesign(50, 0, 2, 50.0, 2.0, 5) pow    <- Power(Normal(), PointMassPrior(.4, 1)) summary(design, \"Power\" = pow) #> TwoStageDesign: n1 =  50  #>            futility |            continue           | efficacy #>        x1:    -0.00 |  0.09  0.46  1.00  1.54  1.91 |  2.00 #>    c2(x1):     +Inf | +2.00 +2.00 +2.00 +2.00 +2.00 |  -Inf #>    n2(x1):        0 |    50    50    50    50    50 |     0 #>     Power:      0.739 #>"},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":null,"dir":"Reference","previous_headings":"","what":"Adaptive Optimal Two-Stage Designs — adoptr","title":"Adaptive Optimal Two-Stage Designs — adoptr","text":"adoptr package provides functionality explore custom optimal two-stage designs one- two-arm superiority tests. details theoretical background see doi:10.1002/sim.8291 doi:10.18637/jss.v098.i09. adoptr makes heavy use S4 class system. good place start learning can found .","code":""},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":"quickstart","dir":"Reference","previous_headings":"","what":"Quickstart","title":"Adaptive Optimal Two-Stage Designs — adoptr","text":"sample workflow quick demo capabilities, see . detailed description background usage adoptr can found doi:10.18637/jss.v098.i09 . variety examples presented validation report hosted .","code":""},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":"designs","dir":"Reference","previous_headings":"","what":"Designs","title":"Adaptive Optimal Two-Stage Designs — adoptr","text":"adoptr currently supports TwoStageDesign, GroupSequentialDesign, OneStageDesign.","code":""},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":"data-distributions","dir":"Reference","previous_headings":"","what":"Data distributions","title":"Adaptive Optimal Two-Stage Designs — adoptr","text":"Currently, implemented data distribution Normal (one two arms).","code":""},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":"priors","dir":"Reference","previous_headings":"","what":"Priors","title":"Adaptive Optimal Two-Stage Designs — adoptr","text":"ContinuousPrior PointMassPrior supported single parameter DataDistribution.","code":""},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":"scores","dir":"Reference","previous_headings":"","what":"Scores","title":"Adaptive Optimal Two-Stage Designs — adoptr","text":"See Scores information basic system representing scores. Available scores ConditionalPower, ConditionalSampleSize, Power, ExpectedSampleSize.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Adaptive Optimal Two-Stage Designs — adoptr","text":"Maintainer: Maximilian Pilz maximilian.pilz@itwm.fraunhofer.de (ORCID) Authors: Kevin Kunzmann kevin.kunzmann@boehringer-ingelheim.com (ORCID) [copyright holder] Jan Meis meis@imbi.uni-heidelberg.de (ORCID) Nico Bruder bruder@imbi.uni-heidelberg.de","code":""},{"path":"https://optad.github.io/adoptr/reference/boundary-designs.html","id":null,"dir":"Reference","previous_headings":"","what":"Boundary designs — get_lower_boundary_design","title":"Boundary designs — get_lower_boundary_design","text":"optimization method minimize based package nloptr. requires upper lower boundaries optimization. boundaries can computed via lower_boundary_design respectively upper_boundary_design. implemented default minimize. Note minimize allows user define boundary designs, .","code":""},{"path":"https://optad.github.io/adoptr/reference/boundary-designs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Boundary designs — get_lower_boundary_design","text":"","code":"get_lower_boundary_design(initial_design, ...)  get_upper_boundary_design(initial_design, ...)  # S4 method for OneStageDesign get_lower_boundary_design(initial_design, n1 = 1, c1_buffer = 2, ...)  # S4 method for GroupSequentialDesign get_lower_boundary_design(   initial_design,   n1 = 1,   n2_pivots = 1,   c1_buffer = 2,   c2_buffer = 2,   ... )  # S4 method for TwoStageDesign get_lower_boundary_design(   initial_design,   n1 = 1,   n2_pivots = 1,   c1_buffer = 2,   c2_buffer = 2,   ... )  # S4 method for OneStageDesign get_upper_boundary_design(   initial_design,   n1 = 5 * initial_design@n1,   c1_buffer = 2,   ... )  # S4 method for GroupSequentialDesign get_upper_boundary_design(   initial_design,   n1 = 5 * initial_design@n1,   n2_pivots = 5 * initial_design@n2_pivots,   c1_buffer = 2,   c2_buffer = 2,   ... )  # S4 method for TwoStageDesign get_upper_boundary_design(   initial_design,   n1 = 5 * initial_design@n1,   n2_pivots = 5 * initial_design@n2_pivots,   c1_buffer = 2,   c2_buffer = 2,   ... )"},{"path":"https://optad.github.io/adoptr/reference/boundary-designs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Boundary designs — get_lower_boundary_design","text":"initial_design initial design ... optional arguments values c1f c1e initial design shifted c1f - c1_buffer c1e - c1_buffer get_lower_boundary_design, respectively, c1f + c1_buffer c1e + c1_buffer get_upper_boundary_design. handled analogously c2_pivots c2_buffer. n1 bound first-stage sample size n1 c1_buffer shift early-stopping boundaries initial ones n2_pivots bound second-stage sample size n2 c2_buffer shift final decision boundary initial one","code":""},{"path":"https://optad.github.io/adoptr/reference/boundary-designs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Boundary designs — get_lower_boundary_design","text":"object class TwoStageDesign.","code":""},{"path":"https://optad.github.io/adoptr/reference/boundary-designs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Boundary designs — get_lower_boundary_design","text":"","code":"initial_design <- TwoStageDesign(   n1    = 25,   c1f   = 0,   c1e   = 2.5,   n2    = 50,   c2    = 1.96,   order = 7L   ) get_lower_boundary_design(initial_design) #> TwoStageDesign<n1=1;-2.0<=x1<=0.5:n2=1>"},{"path":"https://optad.github.io/adoptr/reference/bounds.html","id":null,"dir":"Reference","previous_headings":"","what":"Get support of a prior or data distribution — bounds","title":"Get support of a prior or data distribution — bounds","text":"bounds() returns range support prior data distribution.","code":""},{"path":"https://optad.github.io/adoptr/reference/bounds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get support of a prior or data distribution — bounds","text":"","code":"bounds(dist, ...)  # S4 method for PointMassPrior bounds(dist, ...)  # S4 method for ContinuousPrior bounds(dist, ...)"},{"path":"https://optad.github.io/adoptr/reference/bounds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get support of a prior or data distribution — bounds","text":"dist univariate distribution object ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/bounds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get support of a prior or data distribution — bounds","text":"numeric length two, c(lower, upper)","code":""},{"path":"https://optad.github.io/adoptr/reference/bounds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get support of a prior or data distribution — bounds","text":"","code":"bounds(PointMassPrior(c(0, .5), c(.3, .7))) #> [1] 0.0 0.5 # > 0.3 0.7  bounds(ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4))) #> [1] 0.2 0.4 # > 0.2 0.4"},{"path":"https://optad.github.io/adoptr/reference/composite.html","id":null,"dir":"Reference","previous_headings":"","what":"Score Composition — composite","title":"Score Composition — composite","text":"composite defines new composite scores point-wise evaluation scores valid numerical expression.","code":""},{"path":"https://optad.github.io/adoptr/reference/composite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score Composition — composite","text":"","code":"composite(expr, label = NA_character_)  # S4 method for CompositeScore,TwoStageDesign evaluate(s, design, ...)"},{"path":"https://optad.github.io/adoptr/reference/composite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score Composition — composite","text":"expr Expression (curly brackets); must contain least one score variable; multiple scores used, must either conditional unconditional. Currently, non-score variables supported label object label (string) s object class CompositeScore design object ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/composite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score Composition — composite","text":"object class CompositeConditionalScore CompositeUnconditionalScore depending class scores used expr","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/composite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Score Composition — composite","text":"","code":"ess   <- ExpectedSampleSize(Normal(), PointMassPrior(.4, 1)) power <- Power(Normal(), PointMassPrior(.4, 1))  # linear combination: composite({ess - 50*power}) #> E[n(x1)]  - 50 * Pr[x2>=c2(x1)]    # control flow (e.g. for and while loops) composite({   res <- 0   for (i in 1:3) {      res <- res + ess   }   res }) #> res <- 0; for (i in 1:3) { #>     res <- res + E[n(x1)]  #> }; res   # functional composition composite({log(ess)}) #> log(E[n(x1)] )  cp <- ConditionalPower(Normal(), PointMassPrior(.4, 1)) composite({3*cp}) #> 3 * Pr[x2>=c2(x1)|x1]"},{"path":"https://optad.github.io/adoptr/reference/condition.html","id":null,"dir":"Reference","previous_headings":"","what":"Condition a prior on an interval — condition","title":"Condition a prior on an interval — condition","text":"Restrict object class Prior sub-interval re-normalize PDF.","code":""},{"path":"https://optad.github.io/adoptr/reference/condition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Condition a prior on an interval — condition","text":"","code":"condition(dist, interval, ...)  # S4 method for PointMassPrior,numeric condition(dist, interval, ...)  # S4 method for ContinuousPrior,numeric condition(dist, interval, ...)"},{"path":"https://optad.github.io/adoptr/reference/condition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Condition a prior on an interval — condition","text":"dist univariate distribution object interval length-two numeric vector giving parameter interval condition ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/condition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Condition a prior on an interval — condition","text":"conditional Prior given interval","code":""},{"path":"https://optad.github.io/adoptr/reference/condition.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Condition a prior on an interval — condition","text":"","code":"tmp <- condition(PointMassPrior(c(0, .5), c(.3, .7)), c(-1, .25)) expectation(tmp, identity) # 0 #> [1] 0  tmp <- condition(     ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)),     c(.3, .5) ) bounds(tmp) # c(.3, .4) #> [1] 0.3 0.4"},{"path":"https://optad.github.io/adoptr/reference/critical-values.html","id":null,"dir":"Reference","previous_headings":"","what":"Query critical values of a design — c2","title":"Query critical values of a design — c2","text":"Methods access stage-two critical values TwoStageDesign. c2 returns stage-two critical value conditional stage-one test statistic.","code":""},{"path":"https://optad.github.io/adoptr/reference/critical-values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Query critical values of a design — c2","text":"","code":"c2(d, x1, ...)  # S4 method for TwoStageDesign,numeric c2(d, x1, ...)  # S4 method for OneStageDesign,numeric c2(d, x1, ...)"},{"path":"https://optad.github.io/adoptr/reference/critical-values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Query critical values of a design — c2","text":"d design x1 stage-one test statistic ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/critical-values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Query critical values of a design — c2","text":"critical value function c2 design d position x1","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/critical-values.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Query critical values of a design — c2","text":"","code":"design <- TwoStageDesign(   n1    = 25,   c1f   = 0,   c1e   = 2.5,   n2    = 50,   c2    = 1.96,   order = 7L )  c2(design, 2.2) # 1.96 #> [1] 1.96 c2(design, 3.0) # -Inf #> [1] -Inf c2(design, -1.0) # Inf #> [1] Inf  design <- TwoStageDesign(    n1    = 25,    c1f   = 0,    c1e   = 2.5,    n2    = 50,    c2    = 1.96,    order = 7L )  c2(design, 2.2) # 1.96 #> [1] 1.96 c2(design, 3.0) # -Inf #> [1] -Inf c2(design, -1.0) # Inf #> [1] Inf"},{"path":"https://optad.github.io/adoptr/reference/cumulative_distribution_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative distribution function — cumulative_distribution_function","title":"Cumulative distribution function — cumulative_distribution_function","text":"cumulative_distribution_function evaluates cumulative distribution function specific distribution dist point x.","code":""},{"path":"https://optad.github.io/adoptr/reference/cumulative_distribution_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative distribution function — cumulative_distribution_function","text":"","code":"cumulative_distribution_function(dist, x, n, theta, ...)  # S4 method for Binomial,numeric,numeric,numeric cumulative_distribution_function(dist, x, n, theta, ...)  # S4 method for Normal,numeric,numeric,numeric cumulative_distribution_function(dist, x, n, theta, ...)  # S4 method for Student,numeric,numeric,numeric cumulative_distribution_function(dist, x, n, theta, ...)"},{"path":"https://optad.github.io/adoptr/reference/cumulative_distribution_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative distribution function — cumulative_distribution_function","text":"dist univariate distribution object x outcome n sample size theta distribution parameter ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/cumulative_distribution_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative distribution function — cumulative_distribution_function","text":"value cumulative distribution function point x.","code":""},{"path":"https://optad.github.io/adoptr/reference/cumulative_distribution_function.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative distribution function — cumulative_distribution_function","text":"distribution Binomial, theta denotes rate difference intervention control group. , mean assumed √ n  theta. distribution Normal, mean assumed √ n  theta.","code":""},{"path":"https://optad.github.io/adoptr/reference/cumulative_distribution_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative distribution function — cumulative_distribution_function","text":"","code":"cumulative_distribution_function(Binomial(.1, TRUE), 1, 50, .3) #> [1] 0.004310344  cumulative_distribution_function(Normal(), 1, 50, .3) #> [1] 0.3085375  cumulative_distribution_function(Student(two_armed = FALSE), .75, 50, .9) #> [1] 1.062003e-08"},{"path":"https://optad.github.io/adoptr/reference/expectation.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected value of a function — expectation","title":"Expected value of a function — expectation","text":"Computes expected value vectorized, univariate function f respect distribution dist. .e., E[f(X)].","code":""},{"path":"https://optad.github.io/adoptr/reference/expectation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected value of a function — expectation","text":"","code":"expectation(dist, f, ...)  # S4 method for PointMassPrior,function expectation(dist, f, ...)  # S4 method for ContinuousPrior,function expectation(dist, f, ...)"},{"path":"https://optad.github.io/adoptr/reference/expectation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected value of a function — expectation","text":"dist univariate distribution object f univariate function, must vectorized ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/expectation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected value of a function — expectation","text":"numeric, expected value f respect dist","code":""},{"path":"https://optad.github.io/adoptr/reference/expectation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expected value of a function — expectation","text":"","code":"expectation(PointMassPrior(c(0, .5), c(.3, .7)), identity) #> [1] 0.35 # > .35  expectation(     ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)),     identity ) #> [1] 0.3 # > 0.3"},{"path":"https://optad.github.io/adoptr/reference/get_initial_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Initial design — get_initial_design","title":"Initial design — get_initial_design","text":"optimization method minimize requires initial design optimization. function get_initial_design provides initial guess based fixed design fulfills constraints type error rate power. Note situation-specific initial design may much efficient.","code":""},{"path":"https://optad.github.io/adoptr/reference/get_initial_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initial design — get_initial_design","text":"","code":"get_initial_design(   theta,   alpha,   beta,   type = c(\"two-stage\", \"group-sequential\", \"one-stage\"),   dist = Normal(),   order = 7L,   ... )"},{"path":"https://optad.github.io/adoptr/reference/get_initial_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initial design — get_initial_design","text":"theta alternative effect size normal case, rate difference alternative binomial case alpha maximal type error rate beta maximale type II error rate type two-stage, group-sequential, one-stage design requried? dist distribution test statistic order desired integration order ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/get_initial_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initial design — get_initial_design","text":"object class TwoStageDesign.","code":""},{"path":"https://optad.github.io/adoptr/reference/get_initial_design.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Initial design — get_initial_design","text":"distribution test statistic specified dist. default assumes two-armed z-test.","code":""},{"path":"https://optad.github.io/adoptr/reference/get_initial_design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Initial design — get_initial_design","text":"","code":"init <- get_initial_design(    theta = 0.3,    alpha = 0.025,    beta  = 0.2,    type  = \"two-stage\",    dist  = Normal(two_armed = FALSE),    order = 7L )"},{"path":"https://optad.github.io/adoptr/reference/make_tunable.html","id":null,"dir":"Reference","previous_headings":"","what":"Fix parameters during optimization — make_tunable","title":"Fix parameters during optimization — make_tunable","text":"methods make_fixed make_tunable can used modify 'tunability' status parameters TwoStageDesign object. Tunable parameters optimized , non-tunable ('fixed') parameters considered given altered optimization.","code":""},{"path":"https://optad.github.io/adoptr/reference/make_tunable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fix parameters during optimization — make_tunable","text":"","code":"make_tunable(x, ...)  # S4 method for TwoStageDesign make_tunable(x, ...)  make_fixed(x, ...)  # S4 method for TwoStageDesign make_fixed(x, ...)"},{"path":"https://optad.github.io/adoptr/reference/make_tunable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fix parameters during optimization — make_tunable","text":"x TwoStageDesign object ... unquoted names slots tunability status changed.","code":""},{"path":"https://optad.github.io/adoptr/reference/make_tunable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fix parameters during optimization — make_tunable","text":"updated object class TwoStageDesign","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/make_tunable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fix parameters during optimization — make_tunable","text":"","code":"design <- TwoStageDesign(25, 0, 2, 25, 2, order = 5) # default: all parameters are tunable (except integration pivots, # weights and tunability status itself) design@tunable #>             n1            c1f            c1e      n2_pivots      c2_pivots  #>           TRUE           TRUE           TRUE           TRUE           TRUE  #> x1_norm_pivots        weights        tunable  #>          FALSE          FALSE          FALSE   # make n1 and the pivots of n2 fixed (not changed during optimization) design <- make_fixed(design, n1, n2_pivots) design@tunable #>             n1            c1f            c1e      n2_pivots      c2_pivots  #>          FALSE           TRUE           TRUE          FALSE           TRUE  #> x1_norm_pivots        weights        tunable  #>          FALSE          FALSE          FALSE   # make them tunable again design <- make_tunable(design, n1, n2_pivots) design@tunable #>             n1            c1f            c1e      n2_pivots      c2_pivots  #>           TRUE           TRUE           TRUE           TRUE           TRUE  #> x1_norm_pivots        weights        tunable  #>          FALSE          FALSE          FALSE"},{"path":"https://optad.github.io/adoptr/reference/minimize.html","id":null,"dir":"Reference","previous_headings":"","what":"Find optimal two-stage design by constraint minimization — minimize","title":"Find optimal two-stage design by constraint minimization — minimize","text":"minimize takes unconditional score constraint set (constraint) solves corresponding minimization problem using nloptr (using COBYLA default). initial design defined. also possible define lower- upper-boundary designs. done, boundaries determined automatically heuristically.","code":""},{"path":"https://optad.github.io/adoptr/reference/minimize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find optimal two-stage design by constraint minimization — minimize","text":"","code":"minimize(   objective,   subject_to,   initial_design,   lower_boundary_design = get_lower_boundary_design(initial_design),   upper_boundary_design = get_upper_boundary_design(initial_design),   opts = list(algorithm = \"NLOPT_LN_COBYLA\", xtol_rel = 1e-05, maxeval = 10000),   ... )"},{"path":"https://optad.github.io/adoptr/reference/minimize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find optimal two-stage design by constraint minimization — minimize","text":"objective objective function subject_to constraint collection initial_design initial guess (x0 nloptr) lower_boundary_design design specifying lower boundary. upper_boundary_design design specifying upper boundary opts options list passed nloptr ... optional arguments passed nloptr","code":""},{"path":"https://optad.github.io/adoptr/reference/minimize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find optimal two-stage design by constraint minimization — minimize","text":"list elements: design resulting optimal design nloptr_return Output corresponding nloptr call call_args arguments given optimization call","code":""},{"path":"https://optad.github.io/adoptr/reference/minimize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find optimal two-stage design by constraint minimization — minimize","text":"","code":"# Define Type one error rate toer <- Power(Normal(), PointMassPrior(0.0, 1))  # Define Power at delta = 0.4 pow <- Power(Normal(), PointMassPrior(0.4, 1))  # Define expected sample size at delta = 0.4 ess <- ExpectedSampleSize(Normal(), PointMassPrior(0.4, 1))  # Compute design minimizing ess subject to power and toer constraints # \\donttest{ minimize(     ess,     subject_to(       toer <= 0.025,       pow  >= 0.9    ),     initial_design = TwoStageDesign(50, .0, 2.0, 60.0, 2.0, 5L)  ) #> $design #> TwoStageDesign<n1=68;0.3<=x1<=2.3:n2=26-131>  #>  #> $nloptr_return #>  #> Call: #> nloptr::nloptr(x0 = tunable_parameters(initial_design), eval_f = f_obj,  #>     lb = tunable_parameters(lower_boundary_design), ub = tunable_parameters(upper_boundary_design),  #>     eval_g_ineq = g_cnstr, opts = opts) #>  #>  #> Minimization using NLopt version 2.7.1  #>  #> NLopt solver status: 4 ( NLOPT_XTOL_REACHED: Optimization stopped because  #> xtol_rel or xtol_abs (above) was reached. ) #>  #> Number of Iterations....: 3990  #> Termination conditions:  xtol_rel: 1e-05\tmaxeval: 10000  #> Number of inequality constraints:  3  #> Number of equality constraints:    0  #> Optimal value of objective function:  99.2099508305843  #> Optimal value of controls: 67.77852 0.2812201 2.26569 126.9927 111.6292 86.5138 57.48934 32.48944 2.668702  #> 2.35649 1.822003 1.113608 0.3340881 #>  #>  #>  #> $call_args #> $call_args$objective #> E[n(x1)]  #>  #> $call_args$subject_to #> An object of class \"ConstraintsCollection\" #> Slot \"unconditional_constraints\": #> [[1]] #> Pr[x2>=c2(x1)] <= 0.025  #>  #> [[2]] #> -Pr[x2>=c2(x1)]  <= -0.9  #>  #>  #> Slot \"conditional_constraints\": #> list() #>  #>  #> $call_args$initial_design #> TwoStageDesign<n1=50;0.0<=x1<=2.0:n2=60>  #>  #> $call_args$lower_boundary_design #> TwoStageDesign<n1=1;-2.0<=x1<=0.0:n2=1>  #>  #> $call_args$upper_boundary_design #> TwoStageDesign<n1=250;2.0<=x1<=4.0:n2=300>  #>  #> $call_args$opts #> $call_args$opts$algorithm #> [1] \"NLOPT_LN_COBYLA\" #>  #> $call_args$opts$xtol_rel #> [1] 1e-05 #>  #> $call_args$opts$maxeval #> [1] 10000 #>  #>  #>  #> attr(,\"class\") #> [1] \"adoptrOptimizationResult\" \"list\"                     # }"},{"path":"https://optad.github.io/adoptr/reference/n.html","id":null,"dir":"Reference","previous_headings":"","what":"Query sample size of a design — n1","title":"Query sample size of a design — n1","text":"Methods access stage-one, stage-two, overall sample size TwoStageDesign. n1 returns first-stage sample size design, n2 stage-two sample size conditional stage-one test statistic n overall sample size n1 + n2. Internally, objects class TwoStageDesign allow non-natural, real sample sizes allow smooth optimization (cf. minimize details). optional argument round allows switch internal real representation rounded version (rounding next positive integer).","code":""},{"path":"https://optad.github.io/adoptr/reference/n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Query sample size of a design — n1","text":"","code":"n1(d, ...)  # S4 method for TwoStageDesign n1(d, round = TRUE, ...)  n2(d, x1, ...)  # S4 method for TwoStageDesign,numeric n2(d, x1, round = TRUE, ...)  n(d, x1, ...)  # S4 method for TwoStageDesign,numeric n(d, x1, round = TRUE, ...)  # S4 method for GroupSequentialDesign,numeric n2(d, x1, round = TRUE, ...)  # S4 method for OneStageDesign,numeric n2(d, x1, ...)"},{"path":"https://optad.github.io/adoptr/reference/n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Query sample size of a design — n1","text":"d design ... optional arguments round logical sample sizes rounded next integer? x1 stage-one test statistic","code":""},{"path":"https://optad.github.io/adoptr/reference/n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Query sample size of a design — n1","text":"sample size value design d point x1","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Query sample size of a design — n1","text":"","code":"design <- TwoStageDesign(    n1    = 25,    c1f   = 0,    c1e   = 2.5,    n2    = 50,    c2    = 1.96,    order = 7L )  n1(design) # 25 #> [1] 25 design@n1 # 25 #> [1] 25  n(design, x1 = 2.2) # 75 #> [1] 75"},{"path":"https://optad.github.io/adoptr/reference/plot-TwoStageDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot TwoStageDesign with optional set of conditional scores — plot,TwoStageDesign-method","title":"Plot TwoStageDesign with optional set of conditional scores — plot,TwoStageDesign-method","text":"method allows plot stage-two sample size decision boundary functions chosen design.","code":""},{"path":"https://optad.github.io/adoptr/reference/plot-TwoStageDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot TwoStageDesign with optional set of conditional scores — plot,TwoStageDesign-method","text":"","code":"# S4 method for TwoStageDesign plot(x, y = NULL, ..., rounded = TRUE, k = 100)"},{"path":"https://optad.github.io/adoptr/reference/plot-TwoStageDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot TwoStageDesign with optional set of conditional scores — plot,TwoStageDesign-method","text":"x design plot y used ... named ConditinonalScores plot design /graphic parameters rounded n-values rounded? k number points use plotting","code":""},{"path":"https://optad.github.io/adoptr/reference/plot-TwoStageDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot TwoStageDesign with optional set of conditional scores — plot,TwoStageDesign-method","text":"plot two-stage design","code":""},{"path":"https://optad.github.io/adoptr/reference/plot-TwoStageDesign-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot TwoStageDesign with optional set of conditional scores — plot,TwoStageDesign-method","text":"TwoStageDesign user-defined elements class ConditionalScore.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/plot-TwoStageDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot TwoStageDesign with optional set of conditional scores — plot,TwoStageDesign-method","text":"","code":"design <- TwoStageDesign(50, 0, 2, 50, 2, 5) cp     <- ConditionalPower(dist = Normal(), prior = PointMassPrior(.4, 1)) plot(design, \"Conditional Power\" = cp, cex.axis = 2)"},{"path":"https://optad.github.io/adoptr/reference/posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute posterior distribution — posterior","title":"Compute posterior distribution — posterior","text":"Return posterior distribution given observing stage-one outcome.","code":""},{"path":"https://optad.github.io/adoptr/reference/posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute posterior distribution — posterior","text":"","code":"posterior(dist, prior, x1, n1, ...)  # S4 method for DataDistribution,PointMassPrior,numeric posterior(dist, prior, x1, n1, ...)  # S4 method for DataDistribution,ContinuousPrior,numeric posterior(dist, prior, x1, n1, ...)"},{"path":"https://optad.github.io/adoptr/reference/posterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute posterior distribution — posterior","text":"dist univariate distribution object prior Prior object x1 stage-one test statistic n1 stage-one sample size ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute posterior distribution — posterior","text":"Object class Prior","code":""},{"path":"https://optad.github.io/adoptr/reference/posterior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute posterior distribution — posterior","text":"","code":"posterior(Normal(), PointMassPrior(0, 1), 2, 20) #> PointMass<0.00>   tmp <- ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)) posterior(Normal(), tmp, 2, 20) #> ContinuousPrior<[0.2,0.4]>"},{"path":"https://optad.github.io/adoptr/reference/predictive_cdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictive CDF — predictive_cdf","title":"Predictive CDF — predictive_cdf","text":"predictive_cdf() evaluates predictive CDF model specified DataDistribution dist Prior given stage-one outcome.","code":""},{"path":"https://optad.github.io/adoptr/reference/predictive_cdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictive CDF — predictive_cdf","text":"","code":"predictive_cdf(dist, prior, x1, n1, ...)  # S4 method for DataDistribution,PointMassPrior,numeric predictive_cdf(dist, prior, x1, n1, ...)  # S4 method for DataDistribution,ContinuousPrior,numeric predictive_cdf(   dist,   prior,   x1,   n1,   k = 10 * (prior@support[2] - prior@support[1]) + 1,   ... )"},{"path":"https://optad.github.io/adoptr/reference/predictive_cdf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictive CDF — predictive_cdf","text":"dist univariate distribution object prior Prior object x1 stage-one test statistic n1 stage-one sample size ... optional arguments k number pivots crude integral approximation","code":""},{"path":"https://optad.github.io/adoptr/reference/predictive_cdf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predictive CDF — predictive_cdf","text":"numeric, value predictive CDF","code":""},{"path":"https://optad.github.io/adoptr/reference/predictive_cdf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictive CDF — predictive_cdf","text":"","code":"predictive_cdf(Normal(), PointMassPrior(.0, 1), 0, 20) # .5 #> [1] 0.5  tmp <- ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)) predictive_cdf(Normal(), tmp, 2, 20) #> [1] 0.8455245"},{"path":"https://optad.github.io/adoptr/reference/predictive_pdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictive PDF — predictive_pdf","title":"Predictive PDF — predictive_pdf","text":"predictive_pdf() evaluates predictive PDF model specified DataDistribution dist Prior given stage-one outcome.","code":""},{"path":"https://optad.github.io/adoptr/reference/predictive_pdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictive PDF — predictive_pdf","text":"","code":"predictive_pdf(dist, prior, x1, n1, ...)  # S4 method for DataDistribution,PointMassPrior,numeric predictive_pdf(dist, prior, x1, n1, ...)  # S4 method for DataDistribution,ContinuousPrior,numeric predictive_pdf(   dist,   prior,   x1,   n1,   k = 10 * (prior@support[2] - prior@support[1]) + 1,   ... )"},{"path":"https://optad.github.io/adoptr/reference/predictive_pdf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictive PDF — predictive_pdf","text":"dist univariate distribution object prior Prior object x1 stage-one test statistic n1 stage-one sample size ... optional arguments k number pivots crude integral approximation","code":""},{"path":"https://optad.github.io/adoptr/reference/predictive_pdf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predictive PDF — predictive_pdf","text":"numeric, value predictive PDF","code":""},{"path":"https://optad.github.io/adoptr/reference/predictive_pdf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictive PDF — predictive_pdf","text":"","code":"predictive_pdf(Normal(), PointMassPrior(.3, 1), 1.5, 20) # ~.343 #> [1] 0.3426953  tmp <- ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)) predictive_pdf(Normal(), tmp, 2, 20) #> [1] 0.2302199"},{"path":"https://optad.github.io/adoptr/reference/print.adoptrOptimizationResult.html","id":null,"dir":"Reference","previous_headings":"","what":"Printing an optimization result — print.adoptrOptimizationResult","title":"Printing an optimization result — print.adoptrOptimizationResult","text":"Printing optimization result","code":""},{"path":"https://optad.github.io/adoptr/reference/print.adoptrOptimizationResult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Printing an optimization result — print.adoptrOptimizationResult","text":"","code":"print(x, ...)"},{"path":"https://optad.github.io/adoptr/reference/print.adoptrOptimizationResult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Printing an optimization result — print.adoptrOptimizationResult","text":"x object print ... arguments passed form methods","code":""},{"path":"https://optad.github.io/adoptr/reference/probability_density_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Probability density function — probability_density_function","title":"Probability density function — probability_density_function","text":"probability_density_function evaluates probability density function specific distribution dist point x.","code":""},{"path":"https://optad.github.io/adoptr/reference/probability_density_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probability density function — probability_density_function","text":"","code":"probability_density_function(dist, x, n, theta, ...)  # S4 method for Binomial,numeric,numeric,numeric probability_density_function(dist, x, n, theta, ...)  # S4 method for Normal,numeric,numeric,numeric probability_density_function(dist, x, n, theta, ...)  # S4 method for Student,numeric,numeric,numeric probability_density_function(dist, x, n, theta, ...)"},{"path":"https://optad.github.io/adoptr/reference/probability_density_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probability density function — probability_density_function","text":"dist univariate distribution object x outcome n sample size theta distribution parameter ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/probability_density_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probability density function — probability_density_function","text":"value probability density function point x.","code":""},{"path":"https://optad.github.io/adoptr/reference/probability_density_function.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Probability density function — probability_density_function","text":"distribution Binomial, theta denotes rate difference intervention control group. , mean assumed √ n  theta. distribution Normal, mean assumed √ n  theta.","code":""},{"path":"https://optad.github.io/adoptr/reference/probability_density_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Probability density function — probability_density_function","text":"","code":"probability_density_function(Binomial(.2, FALSE), 1, 50, .3) #> [1] 0.01033349  probability_density_function(Normal(), 1, 50, .3) #> [1] 0.3520653  probability_density_function(Student(TRUE), 1, 40, 1.1) #> [1] 0.0001946335"},{"path":"https://optad.github.io/adoptr/reference/simulate-TwoStageDesign-numeric-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw samples from a two-stage design — simulate,TwoStageDesign,numeric-method","title":"Draw samples from a two-stage design — simulate,TwoStageDesign,numeric-method","text":"simulate allows draw samples given TwoStageDesign.","code":""},{"path":"https://optad.github.io/adoptr/reference/simulate-TwoStageDesign-numeric-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw samples from a two-stage design — simulate,TwoStageDesign,numeric-method","text":"","code":"# S4 method for TwoStageDesign,numeric simulate(object, nsim, dist, theta, seed = NULL, ...)"},{"path":"https://optad.github.io/adoptr/reference/simulate-TwoStageDesign-numeric-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw samples from a two-stage design — simulate,TwoStageDesign,numeric-method","text":"object TwoStageDesign draw samples nsim number simulation runs dist data distribution theta location parameter data distribution seed random seed ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/simulate-TwoStageDesign-numeric-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw samples from a two-stage design — simulate,TwoStageDesign,numeric-method","text":"simulate() returns data.frame nsim rows row (simulation run) following columns theta: effect size n1: First-stage sample size c1f: Stopping futility boundary c1e: Stopping efficacy boundary x1: First-stage outcome n2: Resulting second-stage sample size observing x1 c2: Resulting second-stage decision-boundary observing x1 x2: Second-stage outcome reject: Decision whether null hypothesis rejected ","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/simulate-TwoStageDesign-numeric-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw samples from a two-stage design — simulate,TwoStageDesign,numeric-method","text":"","code":"design <- TwoStageDesign(25, 0, 2, 25, 2, order = 5) # draw samples assuming two-armed design simulate(design, 10, Normal(), .3, 42) #>    theta n1 c1f c1e        x1 n2   c2         x2 reject #> 1    0.3 25   0   2 2.4316186  0 -Inf  1.3048697   TRUE #> 2    0.3 25   0   2 0.4959620 25    2  3.3473056   TRUE #> 3    0.3 25   0   2 1.4237886 25    2 -0.3282005  FALSE #> 4    0.3 25   0   2 1.6935228 25    2  0.7818714  FALSE #> 5    0.3 25   0   2 1.4649285 25    2  0.9273388  FALSE #> 6    0.3 25   0   2 0.9545357 25    2  1.6966106  FALSE #> 7    0.3 25   0   2 2.5721822  0 -Inf -0.2842529   TRUE #> 8    0.3 25   0   2 0.9660011 25    2 -1.5957952  FALSE #> 9    0.3 25   0   2 3.0790839  0 -Inf -2.4404669   TRUE #> 10   0.3 25   0   2 0.9979461 25    2  2.3807735   TRUE"},{"path":"https://optad.github.io/adoptr/reference/subject_to.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a collection of constraints — subject_to","title":"Create a collection of constraints — subject_to","text":"subject_to(...) can used generate object class ConstraintsCollection arbitrary number (un)conditional constraints.","code":""},{"path":"https://optad.github.io/adoptr/reference/subject_to.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a collection of constraints — subject_to","text":"","code":"subject_to(...)  # S4 method for ConstraintsCollection,TwoStageDesign evaluate(s, design, optimization = FALSE, ...)"},{"path":"https://optad.github.io/adoptr/reference/subject_to.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a collection of constraints — subject_to","text":"... either constraint objects (subject_to optional arguments passed evaluate) s object class ConstraintCollection design object optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization.","code":""},{"path":"https://optad.github.io/adoptr/reference/subject_to.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a collection of constraints — subject_to","text":"object class ConstraintsCollection","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/subject_to.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a collection of constraints — subject_to","text":"","code":"# define type one error rate and power toer  <- Power(Normal(), PointMassPrior(0.0, 1)) power <- Power(Normal(), PointMassPrior(0.4, 1))  # create constrain collection subject_to(   toer  <= 0.025,   power >= 0.9 ) #> An object of class \"ConstraintsCollection\" #> Slot \"unconditional_constraints\": #> [[1]] #> Pr[x2>=c2(x1)] <= 0.025  #>  #> [[2]] #> -Pr[x2>=c2(x1)]  <= -0.9  #>  #>  #> Slot \"conditional_constraints\": #> list() #>"},{"path":"https://optad.github.io/adoptr/reference/tunable_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Switch between numeric and S4 class representation of a design — tunable_parameters","title":"Switch between numeric and S4 class representation of a design — tunable_parameters","text":"Get tunable parameters design numeric vector via tunable_parameters update design object suitable vector values tunable parameters.","code":""},{"path":"https://optad.github.io/adoptr/reference/tunable_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Switch between numeric and S4 class representation of a design — tunable_parameters","text":"","code":"tunable_parameters(object, ...)  # S4 method for TwoStageDesign tunable_parameters(object, ...)  # S4 method for TwoStageDesign update(object, params, ...)  # S4 method for OneStageDesign update(object, params, ...)"},{"path":"https://optad.github.io/adoptr/reference/tunable_parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Switch between numeric and S4 class representation of a design — tunable_parameters","text":"object TwoStageDesign object update ... optional arguments params vector design parameters, must order returned tunable_parameters","code":""},{"path":"https://optad.github.io/adoptr/reference/tunable_parameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Switch between numeric and S4 class representation of a design — tunable_parameters","text":"tunable_parameters returns numerical values tunable parameters vector. update returns updated design.","code":""},{"path":"https://optad.github.io/adoptr/reference/tunable_parameters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Switch between numeric and S4 class representation of a design — tunable_parameters","text":"tunable slot TwoStageDesign stores information set design parameters considered fixed (changed optimization) tunable (changed optimization). details fix certain parameters make tunable , see make_fixed make_tunable.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/tunable_parameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Switch between numeric and S4 class representation of a design — tunable_parameters","text":"","code":"design  <- TwoStageDesign(25, 0, 2, 25, 2, order = 5) tunable_parameters(design) #>  [1] 25  0  2 25 25 25 25 25  2  2  2  2  2 design2 <- update(design, tunable_parameters(design) + 1) tunable_parameters(design2) #>  [1] 26  1  3 26 26 26 26 26  3  3  3  3  3"},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-101","dir":"Changelog","previous_headings":"","what":"adoptr 1.0.1","title":"adoptr 1.0.1","text":"updated maintainer updated roxygen version fulfill current CRAN requirements","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-100","dir":"Changelog","previous_headings":"","what":"adoptr 1.0.0","title":"adoptr 1.0.0","text":"CRAN release: 2021-06-28 added references article journal statistical software","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-043","dir":"Changelog","previous_headings":"","what":"adoptr 0.4.3","title":"adoptr 0.4.3","text":"corrected class diagram vignette","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-042","dir":"Changelog","previous_headings":"","what":"adoptr 0.4.2","title":"adoptr 0.4.2","text":"CRAN release: 2021-05-28 minor bug/print fixes Student-t data distribution switched GitHub Actions CI/CD","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-040","dir":"Changelog","previous_headings":"","what":"adoptr 0.4.0","title":"adoptr 0.4.0","text":"included JSS article vignette","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-032","dir":"Changelog","previous_headings":"","what":"adoptr 0.3.2","title":"adoptr 0.3.2","text":"CRAN release: 2020-01-09 bugfix binomial pdf/cdf","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-031","dir":"Changelog","previous_headings":"","what":"adoptr 0.3.1","title":"adoptr 0.3.1","text":"added support binomial endpoint initial design creation convenient extended summary() function two stage designs","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-030","dir":"Changelog","previous_headings":"","what":"adoptr 0.3.0","title":"adoptr 0.3.0","text":"CRAN release: 2019-11-25 bugfix pretty printing optimization results streamlined code internal evaluation integral scores optimization; substantial speedup!","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-023","dir":"Changelog","previous_headings":"","what":"adoptr 0.2.3","title":"adoptr 0.2.3","text":"CRAN release: 2019-09-10 reworked class printing system informative minimize() now also returns S3 class object allow pretty-printing","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-022","dir":"Changelog","previous_headings":"","what":"adoptr 0.2.2","title":"adoptr 0.2.2","text":"CRAN release: 2019-07-02 fixed references SIM paper","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-021","dir":"Changelog","previous_headings":"","what":"adoptr 0.2.1","title":"adoptr 0.2.1","text":"added references SIM paper relevant places","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-020","dir":"Changelog","previous_headings":"","what":"adoptr 0.2.0","title":"adoptr 0.2.0","text":"CRAN release: 2019-06-04 new feature: composite scores allows generic expressions just affine score combinations, cf. composite() affine scores (s1 + 2*s2) longer supported, use composite instead consistent class system: conditional scores longer need specification distributions default (need conditional sampel size e.g.). Instead, expected() now requires explicit specification data prior distribution integrate . Vignettes updated fixed broked tests due updated rpact","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-011","dir":"Changelog","previous_headings":"","what":"adoptr 0.1.1","title":"adoptr 0.1.1","text":"CRAN release: 2019-04-01 extended Description field DESCRIPTION full paragraph provided examples user facing functions revision docs","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-010","dir":"Changelog","previous_headings":"","what":"adoptr 0.1.0","title":"adoptr 0.1.0","text":"initial release","code":""}]
